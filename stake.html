<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KLY Advanced Staking Vault</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    :root {
      --primary: #ffd700;
      --secondary: #ffa500;
      --bg-dark: #000814;
      --bg-light: #001d3d;
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, var(--bg-dark), var(--bg-light));
      font-family: 'Orbitron', sans-serif;
      color: var(--primary);
    }

    #app-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      grid-template-columns: 1fr 1fr;
    }

    /* 3D Canvas Section */
    #canvas-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* UI Control Panel */
    .control-panel {
      padding: 2rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      z-index: 10;
    }

    .panel-section {
      background: rgba(0, 20, 40, 0.7);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      backdrop-filter: blur(5px);
    }

    h1 {
      margin-top: 0;
      text-shadow: 0 0 10px var(--primary);
      font-size: 2rem;
    }

    .balance-display {
      font-size: 1.5rem;
      margin: 1rem 0;
    }

    .stake-amount {
      display: flex;
      margin: 1rem 0;
    }

    input[type="range"] {
      flex-grow: 1;
      -webkit-appearance: none;
      height: 8px;
      background: rgba(255, 215, 0, 0.2);
      border-radius: 4px;
      margin: 0 1rem;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 5px var(--primary);
    }

    .stake-button {
      padding: 1rem 2rem;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      border: none;
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      font-weight: bold;
      color: #000;
      cursor: pointer;
      border-radius: 8px;
      box-shadow: 0 0 15px var(--primary);
      transition: all 0.3s ease;
      margin-top: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stake-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 25px var(--primary);
    }

    .stake-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .reward-counter {
      font-size: 2rem;
      text-align: center;
      margin: 1rem 0;
      text-shadow: 0 0 8px var(--primary);
    }

    .status-message {
      min-height: 24px;
      color: var(--secondary);
      margin-top: 1rem;
    }

    /* Floating Tokens */
    .token {
      position: absolute;
      width: 24px;
      height: 24px;
      background: radial-gradient(circle, var(--primary), var(--secondary));
      border-radius: 50%;
      box-shadow: 0 0 10px var(--primary);
      opacity: 0;
      z-index: 5;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      #app-container {
        grid-template-columns: 1fr;
        grid-template-rows: 50vh 50vh;
      }
      
      .control-panel {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <!-- 3D Visualization Area -->
    <div id="canvas-container"></div>
    
    <!-- Control Panel -->
    <div class="control-panel">
      <div class="panel-section">
        <h1>KLY STAKING VAULT</h1>
        <div class="balance-display">
          Balance: <span id="wallet-balance">0</span> KLY
        </div>
      </div>
      
      <div class="panel-section">
        <h2>Stake Tokens</h2>
        <div class="stake-amount">
          <span>0</span>
          <input type="range" id="stake-slider" min="0" max="100" value="50" step="1">
          <span>100</span>
        </div>
        <div class="reward-counter">
          Estimated APY: <span id="apy-display">12.5%</span>
        </div>
        <button id="stake-button" class="stake-button" disabled>
          CONNECT WALLET TO STAKE
        </button>
        <div class="status-message" id="status-message"></div>
      </div>
      
      <div class="panel-section">
        <h2>Your Staked Position</h2>
        <div class="balance-display">
          Staked: <span id="staked-amount">0</span> KLY
        </div>
        <div class="balance-display">
          Rewards: <span id="reward-amount">0</span> KLY
        </div>
        <button id="claim-button" class="stake-button" disabled>
          CLAIM REWARDS
        </button>
      </div>
    </div>
  </div>

  <script>
  // Web3 Configuration
let provider, signer, stakingContract;
const contractAddress = "0x7bBa73C25cf5384b58DBA280eCB49c9749437823"; // ✅ Your actual deployed KLY staking contract

const ABI = [
  {
    "inputs": [{ "internalType": "uint256", "name": "_amount", "type": "uint256" }],
    "name": "stake",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimRewards", // ✅ Corrected function name (not just "claim")
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_user", "type": "address" }],
    "name": "stakedBalance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_user", "type": "address" }],
    "name": "calculateRewards",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf", // from ERC-20 token
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve", // ERC-20 token approval (required before stake)
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
];
    
    // Three.js Variables
    let scene, camera, renderer, vault, particles = [];
    let isWalletConnected = false;
    
    // DOM Elements
    const stakeButton = document.getElementById('stake-button');
    const claimButton = document.getElementById('claim-button');
    const walletBalance = document.getElementById('wallet-balance');
    const stakedAmount = document.getElementById('staked-amount');
    const rewardAmount = document.getElementById('reward-amount');
    const statusMessage = document.getElementById('status-message');
    const stakeSlider = document.getElementById('stake-slider');
    const apyDisplay = document.getElementById('apy-display');
    
    // Initialize the application
    async function init() {
      init3DScene();
      initEventListeners();
      updateUI();
      
      // Check if Web3 provider is available
      if (window.ethereum) {
        try {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          stakingContract = new ethers.Contract(contractAddress, ABI, signer);
          isWalletConnected = true;
          
          // Get initial balances
          await updateBalances();
          updateUI();
        } catch (error) {
          console.error("Error connecting wallet:", error);
          statusMessage.textContent = "Error connecting wallet";
        }
      } else {
        statusMessage.textContent = "Please install MetaMask or another Web3 wallet";
      }
    }
    
    // Initialize 3D scene
    function init3DScene() {
      const container = document.getElementById("canvas-container");
      
      // Scene setup
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      // Vault Orb
      const geometry = new THREE.SphereGeometry(1, 64, 64);
      const material = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        emissive: 0xffa500,
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });
      vault = new THREE.Mesh(geometry, material);
      scene.add(vault);
      
      // Glow Effect
      const glowGeometry = new THREE.SphereGeometry(1.3, 64, 64);
      const glowMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffd700, 
        transparent: true, 
        opacity: 0.1 
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      scene.add(glow);
      
      // Animate glow
      function pulseGlow() {
        gsap.to(glowMaterial, {
          opacity: 0.2,
          duration: 2,
          yoyo: true,
          repeat: -1
        });
      }
      pulseGlow();
      
      // Particle System
      createParticleSystem();
      
      // Lights
      const pointLight = new THREE.PointLight(0xffaa33, 2, 50);
      pointLight.position.set(5, 5, 5);
      scene.add(pointLight);
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);
      
      // Handle window resize
      window.addEventListener("resize", onWindowResize, false);
    }
    
    // Create particle system for floating tokens
    function createParticleSystem() {
      const particleCount = 30;
      const particles = new THREE.Group();
      
      for (let i = 0; i < particleCount; i++) {
        const size = 0.05 + Math.random() * 0.05;
        const geometry = new THREE.SphereGeometry(size, 16, 16);
        const material = new THREE.MeshStandardMaterial({
          color: 0xffff00,
          emissive: 0xffcc00,
          metalness: 0.7,
          roughness: 0.3
        });
        
        const particle = new THREE.Mesh(geometry, material);
        
        // Random position in a sphere around the vault
        const radius = 2 + Math.random() * 3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        particle.position.x = radius * Math.sin(phi) * Math.cos(theta);
        particle.position.y = radius * Math.sin(phi) * Math.sin(theta);
        particle.position.z = radius * Math.cos(phi);
        
        // Store original position for animation
        particle.userData = {
          originalPosition: particle.position.clone(),
          speed: 0.2 + Math.random() * 0.3,
          offset: Math.random() * Math.PI * 2
        };
        
        particles.add(particle);
      }
      
      scene.add(particles);
      
      // Animate particles in the scene update loop
      function animateParticles() {
        const time = Date.now() * 0.001;
        
        particles.children.forEach(particle => {
          const { originalPosition, speed, offset } = particle.userData;
          
          particle.position.x = originalPosition.x + Math.sin(time * speed + offset) * 0.3;
          particle.position.y = originalPosition.y + Math.cos(time * speed * 0.7 + offset) * 0.3;
          particle.position.z = originalPosition.z + Math.sin(time * speed * 0.5 + offset) * 0.3;
        });
      }
      
      // Add to animation loop
      function animate() {
        requestAnimationFrame(animate);
        animateParticles();
        renderer.render(scene, camera);
      }
      animate();
    }
    
    // Window resize handler
    function onWindowResize() {
      const container = document.getElementById("canvas-container");
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }
    
    // Initialize event listeners
    function initEventListeners() {
      stakeButton.addEventListener('click', handleStake);
      claimButton.addEventListener('click', handleClaim);
      stakeSlider.addEventListener('input', updateStakeAmount);
      
      // Connect wallet button if not connected
      if (!isWalletConnected) {
        stakeButton.textContent = "CONNECT WALLET";
        stakeButton.addEventListener('click', connectWallet);
      }
    }
    
    // Update UI based on current state
    function updateUI() {
      if (isWalletConnected) {
        stakeButton.textContent = "STAKE KLY";
        stakeButton.disabled = false;
        claimButton.disabled = false;
      } else {
        stakeButton.textContent = "CONNECT WALLET";
        stakeButton.disabled = false;
        claimButton.disabled = true;
      }
    }
    
    // Connect wallet handler
    async function connectWallet() {
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        stakingContract = new ethers.Contract(contractAddress, contractABI, signer);
        isWalletConnected = true;
        
        await updateBalances();
        updateUI();
        
        // Change button back to stake functionality
        stakeButton.removeEventListener('click', connectWallet);
        stakeButton.addEventListener('click', handleStake);
        
        statusMessage.textContent = "Wallet connected successfully!";
        setTimeout(() => statusMessage.textContent = "", 3000);
      } catch (error) {
        console.error("Wallet connection error:", error);
        statusMessage.textContent = "Error connecting wallet";
      }
    }
    
    // Update balances from blockchain
    async function updateBalances() {
      if (!isWalletConnected) return;
      
      try {
        const address = await signer.getAddress();
        const balance = await stakingContract.balanceOf(address);
        const staked = await stakingContract.stakedBalance(address);
        const rewards = await stakingContract.calculateRewards(address);
        
        walletBalance.textContent = ethers.utils.formatUnits(balance, 18);
        stakedAmount.textContent = ethers.utils.formatUnits(staked, 18);
        rewardAmount.textContent = ethers.utils.formatUnits(rewards, 18);
      } catch (error) {
        console.error("Error fetching balances:", error);
      }
    }
    
    // Update stake amount display
    function updateStakeAmount() {
      const value = stakeSlider.value;
      document.querySelector('.stake-amount span:first-child').textContent = value;
      
      // Dynamic APY calculation (simplified)
      const baseAPY = 12.5;
      const bonus = value / 100 * 5; // Up to 5% bonus for full stake
      apyDisplay.textContent = (baseAPY + bonus).toFixed(2) + "%";
    }
    
    // Handle stake transaction
    async function handleStake() {
      const amount = stakeSlider.value;
      const amountWei = ethers.utils.parseUnits(amount, 18);
      
      try {
        stakeButton.disabled = true;
        statusMessage.textContent = "Processing transaction...";
        
        // Visual token transfer animation
        animateTokenTransfer(amount);
        
        // Smart contract interaction
        const tx = await stakingContract.stake(amountWei);
        statusMessage.textContent = "Transaction sent! Waiting for confirmation...";
        
        await tx.wait();
        statusMessage.textContent = "Staking successful!";
        
        // Update balances
        await updateBalances();
        
        // Visual confirmation
        showConfettiEffect();
        
        setTimeout(() => statusMessage.textContent = "", 3000);
        stakeButton.disabled = false;
      } catch (error) {
        console.error("Staking error:", error);
        statusMessage.textContent = "Error processing transaction";
        stakeButton.disabled = false;
      }
    }
    
    // Handle claim rewards
    async function handleClaim() {
      try {
        claimButton.disabled = true;
        statusMessage.textContent = "Claiming rewards...";
        
        const tx = await stakingContract.claimRewards();
        await tx.wait();
        
        statusMessage.textContent = "Rewards claimed successfully!";
        await updateBalances();
        
        // Visual reward claim effect
        animateRewardClaim();
        
        setTimeout(() => statusMessage.textContent = "", 3000);
        claimButton.disabled = false;
      } catch (error) {
        console.error("Claim error:", error);
        statusMessage.textContent = "Error claiming rewards";
        claimButton.disabled = false;
      }
    }
    
    // Animate token transfer from UI to vault
    function animateTokenTransfer(amount) {
      const container = document.getElementById('app-container');
      const tokenCount = Math.min(amount / 5, 20); // Number of tokens to animate
      
      for (let i = 0; i < tokenCount; i++) {
        const token = document.createElement('div');
        token.className = 'token';
        
        // Position near the stake button
        const buttonRect = stakeButton.getBoundingClientRect();
        token.style.left = (buttonRect.left + buttonRect.width/2 - 12) + 'px';
        token.style.top = (buttonRect.top - 24) + 'px';
        
        container.appendChild(token);
        
        // Animate to vault (center of 3D scene)
        setTimeout(() => {
          token.style.opacity = '1';
          token.style.transition = 'all 1s ease-out';
          
          const canvasRect = document.getElementById('canvas-container').getBoundingClientRect();
          token.style.left = (canvasRect.left + canvasRect.width/2 - 12) + 'px';
          token.style.top = (canvasRect.top + canvasRect.height/2 - 12) + 'px';
          token.style.transform = 'scale(0.5)';
          
          // Remove after animation
          setTimeout(() => {
            token.remove();
          }, 1000);
        }, i * 100);
      }
    }
    
    // Animate reward claim
    function animateRewardClaim() {
      const container = document.getElementById('app-container');
      const canvasRect = document.getElementById('canvas-container').getBoundingClientRect();
      
      // Create reward particles that burst from the vault
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement('div');
        particle.className = 'token';
        particle.style.left = (canvasRect.left + canvasRect.width/2 - 12) + 'px';
        particle.style.top = (canvasRect.top + canvasRect.height/2 - 12) + 'px';
        particle.style.opacity = '1';
        particle.style.width = '16px';
        particle.style.height = '16px';
        
        container.appendChild(particle);
        
        // Random direction and distance
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 100;
        const duration = 800 + Math.random() * 500;
        
        setTimeout(() => {
          particle.style.transition = `all ${duration}ms ease-out`;
          particle.style.left = (canvasRect.left + canvasRect.width/2 + Math.cos(angle) * distance - 8) + 'px';
          particle.style.top = (canvasRect.top + canvasRect.height/2 + Math.sin(angle) * distance - 8) + 'px';
          particle.style.opacity = '0';
          
          // Remove after animation
          setTimeout(() => {
            particle.remove();
          }, duration);
        }, i * 50);
      }
    }
    
    // Show confetti effect
    function showConfettiEffect() {
      // Simple confetti using canvas particles
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'token';
        confetti.style.left = '50%';
        confetti.style.top = '50%';
        confetti.style.opacity = '1';
        confetti.style.width = '10px';
        confetti.style.height = '10px';
        confetti.style.backgroundColor = `hsl(${Math.random() * 60 + 30}, 100%, 50%)`;
        
        document.body.appendChild(confetti);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 200;
        const duration = 1000 + Math.random() * 1000;
        
        setTimeout(() => {
          confetti.style.transition = `all ${duration}ms ease-out`;
          confetti.style.left = `calc(50% + ${Math.cos(angle) * distance}px)`;
          confetti.style.top = `calc(50% + ${Math.sin(angle) * distance + Math.random() * 200}px)`;
          confetti.style.opacity = '0';
          confetti.style.transform = 'rotate(360deg)';
          
          setTimeout(() => {
            confetti.remove();
          }, duration);
        }, i * 20);
      }
    }
    
    // Initialize the app
    window.addEventListener('load', init);
  </script>
</body>
</html>
