<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Drop1155 Mint — Minimal Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Ethers v6 UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; background:#0b0d14; color:#e9e9f0; margin:0; padding:24px }
    .card { max-width:760px; margin:0 auto; background:#121525; border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:16px }
    input { padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,.15); background:#0f1220; color:#fff; width:100% }
    button { padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font-weight:700; }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 }
    .primary { background:linear-gradient(90deg,#6E44FF,#D4AF37); color:#0b0b0b }
    .ghost { background:rgba(255,255,255,.08); color:#fff; border:1px solid rgba(255,255,255,.12) }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f1220; padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,.12); height:200px; overflow:auto; white-space:pre-wrap }
    label { font-size:14px; opacity:.85 }
  </style>
</head>
<body>
<div class="card">
  <h2>Drop1155 Mint — Minimal Test</h2>

  <div class="row">
    <button id="connect" class="ghost">Connect MetaMask</button>
    <span id="who" style="opacity:.8"></span>
  </div>

  <div class="row">
    <div style="flex:1">
      <label>Contract (Drop1155)</label>
      <input id="contract" value="0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989">
    </div>
    <div style="flex:0 0 120px">
      <label>Token ID</label>
      <input id="tokenId" type="number" value="0" min="0">
    </div>
    <div style="flex:0 0 120px">
      <label>Qty</label>
      <input id="qty" type="number" value="1" min="1">
    </div>
  </div>

  <div class="row">
    <button id="read" class="ghost">1) Read Claim</button>
    <button id="simulate" class="ghost">2) Simulate</button>
    <button id="mint" class="primary">3) Mint</button>
  </div>

  <div class="row">
    <div class="log" id="log">Logs will appear here… (also check DevTools Console)</div>
  </div>
</div>

<script>
/* ===== Config ===== */
const BSC_CHAIN_ID = 56;
const READ_RPC = "https://bsc-dataseed.binance.org/";

/* ===== ABIs ===== */
const MECHS_READ_ABI = [
  "function uri(uint256) view returns (string)",
  "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
  "function getClaimConditionById(uint256 _tokenId,uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata) condition)"
];

const MECHS_CLAIM_ABI = [
  "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable"
];

const MECHS_ERROR_ABI = [
  "error DropClaimExceedLimit(uint256 expected,uint256 actual)",
  "error DropClaimExceedMaxSupply(uint256 expected,uint256 actual)",
  "error DropClaimInvalidTokenPrice(address expectedCurrency,uint256 expectedPricePerToken,address actualCurrency,uint256 actualExpectedPricePerToken)",
  "error DropClaimNotStarted(uint256 expected,uint256 actual)",
  "error DropNoActiveCondition()",
  "error DropExceedMaxSupply()",
  "error CurrencyTransferLibFailedNativeTransfer(address recipient,uint256 value)"
  // (you listed more; these are enough for decode demo)
];

const FULL_IFACE = new ethers.Interface([...MECHS_CLAIM_ABI, ...MECHS_ERROR_ABI]);

/* ===== State & DOM ===== */
const readProvider = new ethers.JsonRpcProvider(READ_RPC);
let browserProvider = null, signer = null, userAddr = null, lastClaim = null;

const $ = id => document.getElementById(id);
const logEl = $('log');
function log(...args){ console.log(...args); logEl.textContent += '\n' + args.join(' '); logEl.scrollTop = logEl.scrollHeight; }
function shorten(a){ return a ? a.slice(0,6)+'…'+a.slice(-4) : '—'; }
const ZERO = ethers.ZeroAddress;

/* ===== Error prettifier ===== */
function prettyRevert(e){
  const data = e?.data || e?.error?.data || e?.info?.error?.data || e?.error?.error?.data;
  if (typeof data === "string" && data.startsWith("0x")){
    try {
      const dec = FULL_IFACE.decodeErrorResult(data);
      const args = Array.isArray(dec.args) && dec.args.length
        ? " " + JSON.stringify(dec.args.map(a => (typeof a === "bigint" ? a.toString() : a)))
        : "";
      return `${dec.name}${args}`;
    } catch {}
  }
  return e?.reason || e?.shortMessage || e?.message || 'Unknown error';
}

/* ===== Wallet connect ===== */
async function connect(){
  try{
    if(!window.ethereum) throw new Error('MetaMask not detected.');
    browserProvider = new ethers.BrowserProvider(window.ethereum, 'any');
    await browserProvider.send('eth_requestAccounts',[]);
    const net = await browserProvider.getNetwork();
    if (Number(net.chainId) !== BSC_CHAIN_ID){
      try {
        await browserProvider.send('wallet_switchEthereumChain',[{ chainId:'0x'+BSC_CHAIN_ID.toString(16) }]);
      } catch (err){
        if (err?.code === 4902){
          await browserProvider.send('wallet_addEthereumChain',[{
            chainId:'0x'+BSC_CHAIN_ID.toString(16),
            chainName:'Binance Smart Chain',
            nativeCurrency:{ name:'BNB', symbol:'BNB', decimals:18 },
            rpcUrls:['https://bsc-dataseed1.bnbchain.org','https://bsc-dataseed2.bnbchain.org','https://bsc-dataseed.binance.org'],
            blockExplorerUrls:['https://bscscan.com/']
          }]);
        } else { throw err; }
      }
    }
    signer = await browserProvider.getSigner();
    userAddr = await signer.getAddress();
    $('who').textContent = `Connected: ${shorten(userAddr)}`;
    log('Connected', userAddr);
  }catch(e){ log('Connect error:', e.message || e); }
}

/* ===== Read claim condition ===== */
async function readClaim(){
  const contractAddr = $('contract').value.trim();
  const tokenId = Number($('tokenId').value);
  log('Reading claim for', contractAddr, 'token', tokenId);
  const c = new ethers.Contract(contractAddr, MECHS_READ_ABI, readProvider);
  const condId = await c.getActiveClaimConditionId(tokenId);
  const cond = await c.getClaimConditionById(tokenId, condId);
  lastClaim = {
    pricePerToken: cond.pricePerToken,
    currency: cond.currency,
    quantityLimitPerWallet: cond.quantityLimitPerWallet,
    supplyClaimed: cond.supplyClaimed,
    maxSupply: cond.maxClaimableSupply
  };
  log('Claim:', JSON.stringify({
    pricePerToken: cond.pricePerToken.toString(),
    currency: cond.currency,
    qtyLimitPerWallet: cond.quantityLimitPerWallet.toString(),
    claimed: cond.supplyClaimed.toString(),
    max: cond.maxClaimableSupply.toString()
  }));
  return lastClaim;
}

/* ===== Simulate (eth_call) ===== */
async function simulate(){
  if(!signer) await connect();
  const contractAddr = $('contract').value.trim();
  const tokenId = Number($('tokenId').value);
  const qty = Math.max(1, Number($('qty').value) || 1);

  const claim = lastClaim || await readClaim();
  const isNative = claim.currency.toLowerCase() === ZERO.toLowerCase();
  const pricePer = claim.pricePerToken;
  const totalCost = pricePer * BigInt(qty);
  const currencyAddr = isNative ? ZERO : claim.currency;

  const allowlist = { proof: [], quantityLimitPerWallet: 0n, pricePerToken: pricePer, currency: currencyAddr };
  const args = [userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, '0x'];
  const data = FULL_IFACE.encodeFunctionData("claim", args);

  log('Simulating… value=', isNative ? ethers.formatEther(totalCost) + ' BNB' : '0');
  try{
    await signer.call({ to: contractAddr, data, value: isNative ? totalCost : 0n });
    log('✅ Simulation passed');
  }catch(e){
    log('❌ Simulation revert:', prettyRevert(e));
    throw e;
  }
}

/* ===== Send mint tx ===== */
async function mint(){
  if(!signer) await connect();
  const contractAddr = $('contract').value.trim();
  const tokenId = Number($('tokenId').value);
  const qty = Math.max(1, Number($('qty').value) || 1);

  const claim = lastClaim || await readClaim();
  const isNative = claim.currency.toLowerCase() === ZERO.toLowerCase();
  const pricePer = claim.pricePerToken;
  const totalCost = pricePer * BigInt(qty);
  const currencyAddr = isNative ? ZERO : claim.currency;

  // 1) simulate
  await simulate();

  // 2) estimate & send
  const allowlist = { proof: [], quantityLimitPerWallet: 0n, pricePerToken: pricePer, currency: currencyAddr };
  const args = [userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, '0x'];
  const data = FULL_IFACE.encodeFunctionData("claim", args);

  let gasLimit;
  try{
    const est = await signer.estimateGas({ to: contractAddr, data, value: isNative ? totalCost : 0n });
    gasLimit = (est * 120n) / 100n; // +20%
    log('Gas estimate:', est.toString());
  }catch(e){
    log('Gas estimate failed (will try w/o):', prettyRevert(e));
  }

  log('Sending tx…');
  const tx = await signer.sendTransaction({ to: contractAddr, data, value: isNative ? totalCost : 0n, ...(gasLimit ? { gasLimit } : {}) });
  log('Tx sent:', tx.hash);
  const rec = await tx.wait();
  log('✅ Mined in block', rec.blockNumber, 'status', rec.status);
}

/* ===== Wire UI ===== */
$('connect').onclick = connect;
$('read').onclick = () => readClaim().catch(e=>log('Read error:', prettyRevert(e)));
$('simulate').onclick = () => simulate().catch(e=>log('Sim error:', prettyRevert(e)));
$('mint').onclick = () => mint().catch(e=>log('Mint error:', prettyRevert(e)));
</script>
</body>
</html>
