<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mint Exclusive & Rare NFTs | Tamaquah Nation</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
<style>
  :root {
    --bg: #0A1A24;
    --bg2: #051018;
    --ink: #EAF7FF;
    --sub: #9CCBE3;
    --accent: #73E1FF;
    --gold: #e2c675;
    --metamask: #f6851b;
    --card: rgba(255,255,255,.06);
    --stroke: rgba(255,255,255,.12);
    --glow: 0 0 24px rgba(115,225,255,.35);
    --success: #4ade80;
    --error: #f87171;
    --warning: #fbbf24;
  }
  
  html, body {
    margin: 0;
    background: linear-gradient(180deg, var(--bg), var(--bg2));
    color: var(--ink);
    font-family: 'Inter', system-ui, Arial, sans-serif;
    min-height: 100vh;
  }
  
  .wrap {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }
  
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }
  
  .brand {
    font-weight: 800;
    letter-spacing: .08em;
    font-size: 1.5rem;
    color: var(--accent);
    text-shadow: 0 0 10px rgba(115,225,255,0.3);
  }
  
  .hero {
    text-align: center;
    padding: 2rem 0;
    margin-bottom: 3rem;
  }
  
  .hero h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    margin: 0 0 1rem;
    text-transform: uppercase;
    letter-spacing: .06em;
    background: linear-gradient(90deg, var(--accent), var(--gold));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  .hero p {
    color: var(--sub);
    margin: 0;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
    font-size: 1.1rem;
  }
  
  .wallet-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
  }
  
  .btn {
    background: linear-gradient(90deg, var(--metamask), #f8a34d);
    color: white;
    border: none;
    border-radius: 12px;
    padding: 1rem 2rem;
    font-weight: 700;
    cursor: pointer;
    transition: all .2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  
  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(246, 133, 27, 0.3);
  }
  
  .btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none !important;
  }
  
  .wallet-info {
    display: flex;
    gap: 1rem;
    align-items: center;
    background: rgba(0,0,0,0.2);
    padding: 0.75rem 1.5rem;
    border-radius: 999px;
    font-size: 0.95rem;
  }
  
  .wallet-address {
    font-family: monospace;
    font-size: 0.9rem;
  }
  
  .balance {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }
  
  .balance-amount {
    font-weight: 600;
  }
  
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-top: 2rem;
  }
  
  .card {
    background: var(--card);
    border: 1px solid var(--stroke);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 16px 60px rgba(0,0,0,.35);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  
  .card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, var(--accent), var(--gold));
  }
  
  .card:hover {
    transform: translateY(-8px);
    box-shadow: 0 20px 80px rgba(0,0,0,0.5);
    border-color: rgba(115,225,255,0.3);
  }
  
  .card h2 {
    margin: 0 0 1rem;
    font-size: 1.5rem;
  }
  
  .contract-address {
    font-size: 0.85rem;
    word-break: break-all;
    color: var(--sub);
    margin-bottom: 1rem;
    display: block;
  }
  
  .form-group {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    margin: 1rem 0;
  }
  
  label {
    font-size: 0.95rem;
    opacity: 0.9;
  }
  
  select, input[type=number] {
    background: #0c1d27;
    color: var(--ink);
    border: 1px solid var(--stroke);
    border-radius: 10px;
    padding: 0.75rem 1rem;
    font-family: inherit;
    transition: all 0.2s ease;
    min-width: 100px;
  }
  
  select:hover, input[type=number]:hover {
    border-color: var(--accent);
  }
  
  select:focus, input[type=number]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(115,225,255,0.2);
  }
  
  .preview {
    display: flex;
    gap: 1.5rem;
    margin: 1.5rem 0;
    align-items: flex-start;
  }
  
  .preview img {
    width: 180px;
    height: 180px;
    object-fit: cover;
    border-radius: 12px;
    border: 1px solid var(--stroke);
    box-shadow: 0 20px 60px rgba(0,0,0,.35);
    transition: all 0.3s ease;
    background: linear-gradient(45deg, #0c1d27, #0a2738);
  }
  
  .preview img:hover {
    transform: scale(1.03);
    box-shadow: 0 20px 80px rgba(0,0,0,0.6);
  }
  
  .meta {
    flex: 1;
  }
  
  .nft-name {
    margin: 0 0 0.5rem;
    font-size: 1.25rem;
  }
  
  .stat {
    display: flex;
    justify-content: space-between;
    margin: 0.5rem 0;
    font-size: 0.95rem;
  }
  
  .stat-label {
    color: var(--sub);
  }
  
  .stat-value {
    font-weight: 600;
  }
  
  .mint-btn {
    background: linear-gradient(90deg, var(--accent), #a9ffcb);
    color: #001018;
    border: none;
    border-radius: 12px;
    padding: 1rem 1.5rem;
    font-weight: 700;
    cursor: pointer;
    width: 100%;
    margin-top: 1rem;
    transition: all 0.2s ease;
  }
  
  .mint-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 32px rgba(115,225,255,0.5);
  }
  
  .status {
    min-height: 24px;
    font-size: 0.9rem;
    margin-top: 0.5rem;
    text-align: center;
  }
  
  .status.success {
    color: var(--success);
  }
  
  .status.error {
    color: var(--error);
  }
  
  .status.warning {
    color: var(--warning);
  }
  
  .loading {
    position: relative;
    color: transparent !important;
  }
  
  .loading:after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.2);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }
  
  footer {
    margin-top: 3rem;
    text-align: center;
    color: var(--sub);
    font-size: 0.9rem;
    padding: 1rem;
  }
  
  /* Network indicator */
  .network-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
    padding: 0.5rem 1rem;
    border-radius: 999px;
    background: rgba(0,0,0,0.2);
  }
  
  .network-indicator.valid {
    background: rgba(74, 222, 128, 0.1);
    color: var(--success);
  }
  
  .network-indicator.invalid {
    background: rgba(248, 113, 113, 0.1);
    color: var(--error);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .wrap {
      padding: 1.5rem;
    }
    
    .grid {
      grid-template-columns: 1fr;
    }
    
    .preview {
      flex-direction: column;
    }
    
    .preview img {
      width: 100%;
      height: auto;
      max-height: 300px;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">TAMAQUAH VAULT</div>
  </header>

  <section class="hero">
    <h1>Mint Exclusive & Rare NFTs</h1>
    <p>Connect your MetaMask wallet to mint these unique digital artifacts from our collections.</p>
  </section>

  <div class="wallet-section">
    <button id="connectBtn" class="btn">
      <svg width="20" height="20" viewBox="0 0 40 37" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M36.0115 3.33203L22.2221 14.2493C21.2623 14.9929 19.7377 14.9929 18.7779 14.2493L4.9885 3.33203" stroke="white" stroke-width="6" stroke-linecap="round"/>
        <path d="M26.2086 23.5947L23.3333 26.0413C21.4609 27.6545 18.5391 27.6545 16.6667 26.0413L13.7914 23.5947" stroke="white" stroke-width="6" stroke-linecap="round"/>
        <rect x="1" y="1" width="38" height="35" rx="6" stroke="white" stroke-width="2"/>
      </svg>
      Connect MetaMask
    </button>
    
    <div id="walletInfo" style="display: none;">
      <div class="wallet-info">
        <span id="walletAddress" class="wallet-address"></span>
        <span class="network-indicator">
          <span id="networkName">BSC</span>
        </span>
      </div>
      <div class="wallet-info">
        <span class="balance">
          Balance: <span id="balanceAmount" class="balance-amount">0</span>
          <span id="balanceCurrency">BNB</span>
        </span>
      </div>
    </div>
    
    <div id="connStatus" class="status"></div>
  </div>

  <section class="grid">
    <!-- Ancestral Mechs (BNB) -->
    <div class="card" id="mechsCard">
      <h2>Ancestral Mechs: Bloodline Codex</h2>
      <span class="contract-address">Contract: 0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989</span>
      
      <div class="form-group">
        <label for="mechsTokenId">Token ID</label>
        <select id="mechsTokenId"></select>
        <label for="mechsQty">Quantity</label>
        <input id="mechsQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="mechsImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="mechsName" class="nft-name">—</h3>
          <div class="stat">
            <span class="stat-label">Price/Token:</span>
            <span id="mechsPrice" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Currency:</span>
            <span id="mechsCurrency" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Supply:</span>
            <span id="mechsSupply" class="stat-value">—</span>
          </div>
          <div class="stat">
            <span class="stat-label">Your Balance:</span>
            <span id="mechsBalance" class="stat-value">—</span>
          </div>
        </div>
      </div>

      <button id="mechsMint" class="mint-btn">Mint Mech</button>
      <div id="mechsStatus" class="status"></div>
    </div>

    <!-- Tribal Punk Cryptids (KLY) -->
    <div class="card" id="cryptidsCard">
      <h2>Tribal Punk Cryptids</h2>
      <span class="contract-address">Contract: 0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11</span>
      
      <div class="form-group">
        <label for="cryptidTokenId">Token ID</label>
        <select id="cryptidTokenId"></select>
        <label for="cryptidQty">Quantity</label>
        <input id="cryptidQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="cryptidImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="cryptidName" class="nft-name">—</h3>
          <div class="stat">
            <span class="stat-label">Price/Token:</span>
            <span id="cryptidPrice" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Currency:</span>
            <span id="cryptidCurrency" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Supply:</span>
            <span id="cryptidSupply" class="stat-value">—</span>
          </div>
          <div class="stat">
            <span class="stat-label">Your Balance:</span>
            <span id="cryptidBalance" class="stat-value">—</span>
          </div>
        </div>
      </div>

      <button id="cryptidMint" class="mint-btn">Mint Cryptid</button>
      <div id="cryptidStatus" class="status"></div>
    </div>
  </section>

  <footer>They took the land. We took the future.</footer>
</div>
<script>
  // ------------ CONFIG ------------
  const BSC_CHAIN_ID = 56;
  const CONTRACT_MECHS = "0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989";
  const CONTRACT_CRYPTIDS = "0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11";
  const KLY_TOKEN = "0x2e4fEB2Fe668c8Ebe84f19e6c8fE8Cf8131B4E52";       // ERC-20 (on BSC)

  // Optional price pins
  const FORCED_MECHS_PRICE_BNB = "0.0063"; // keep stable at ~$5, or null
  const FORCED_CRYPTIDS_PRICE_KLY = null;  // read from contract claim condition

  // Read-only RPC for when wallet isn't connected
  const READ_RPC = "https://bsc-dataseed.binance.org/";

  // ------------ TOKEN LISTS ------------
  const T = (id, name, uri)=>({id, name, uri});

  const CRYPTIDS = [
    T(0,  "Wendigo.EXE",                 "ipfs://QmV2X7oUrG5i284sKQPHQJAbQV8HkL788mbZexuCA5oTvx/0"),
    T(1,  "Mask of Memory",              "ipfs://Qmbu7rbrAoG3cJTYEJGGJ6iZsPGpDQxhkJBsKt4QuBJj8N/0"),
    T(2,  "Wolf of Wounded Knee",        "ipfs://QmQm8nSAL56mGypS45f4AZ44xejVPWuktWidfZqAHdJtmk/0"),
    T(3,  "Coastal Sasquatch Punk",      "ipfs://QmV91qcvQmzwUEu4hin91iXqzVn7hn1F9gZ9bmfxnFTQje/0"),
    T(4,  "Anishinaabe Wendigo Protocol","ipfs://QmStEaLkFwNREJ3M4t42hNKvphwjHK1MxjA7CUdW15d6BE/0"),
    T(5,  "Desert Skinwalker Punk",      "ipfs://QmcW6m3B1ygPoMrsr4qVMaNC4uCL1s4EAq2LcdEsCj6iUS/0"),
    T(6,  "Métis Rougarou Rider",        "ipfs://Qmeg78oUMrM1fUGNMVzUNG2G5dEDuD8TLoB9Mh3j3X6zEF/0"),
    T(7,  "Cherokee Skinwalker Firewall","ipfs://QmWNsSbcy2iBmYjK2TCzELZTfzD1ezGj1WvktYiwnWnjjg/0"),
    T(8,  "Wabanaki Webworm",            "ipfs://QmdadZMbe1QMUW5i51smLxEDuWvRWKanLiiHdyb4zH2mbM/0"),
    T(9,  "Deer Woman DAO",              "ipfs://QmTmrUDMXuqnffe1duAEYdJGAKNeSdEsVvKe8dT8YKR4i7/0"),
    T(10, "The Cipherskin Codex",        "ipfs://QmPcWyNf93hwKXxBH5QpseeqmkE296arM1jkg4zcvi3bgC/0"),
    T(11, "Treaty.Exe",                  "ipfs://QmeGbsj4E3w9zaaEnQiSsDUrPUbbTWumn8BemBnsHNdFuR/0"),
    T(12, "Scroll of Unburied Seeds",    "ipfs://QmNXhjcuNvaYDW7PdDi7Erh1jbkhQb6ep15FAYcXVZUByE/0"),
    T(13, "The Disentrancer",            "ipfs://QmQP3hP9YyAkFZwKNkrw5apxEcZ7nAZecshsaE1sdpyGaz/0"),
    T(14, "Ledger Shaman",               "ipfs://QmNj8tHVjp4X1HNBFbm4nbw6mb2vzdMHrYDd8wQuE35qFw/0"),
    T(15, "The Ghost of Paper Genocide","ipfs://QmWbTfxSn4Mybnw3deUiFn3T8PVyyJkiCPZD9C91Sqz9Kk/0"),
    T(16, "Ironroot Codewalker",         "ipfs://QmWMhG22wfXFZufu7E2haVkqoc1XYf4bU8KXvVL6xUZZXW/0"),
    T(17, "Deer Woman 9.0",              "ipfs://QmRieQJ4gpkjMsJkaB99t2M5BX5sns6CWVJPa3HNwASCEB/0"),
    T(18, "Thunderbird 9G",              "ipfs://QmPnk3rYUeqeCevm7pjjfp31WrsUp8CzBP96TVRmmFky7h/0"),
    T(19, "Skinwalker 9S",               "ipfs://Qmbv4hEy6gW68XSUUW46nzYmptaxiWS1vFGig3457W1Wez/0"),
  ];

  const MECHS = [
    T(0, "Skybone Leviathan", "ipfs://QmXZaUkWziGrd2ooyXdQavJmPXCtWFjZrGL9239n4Nu7yU/0"),
    // add more mechs here as you mint them
  ];

  // ------------ ABIs ------------
  const DROP1155_ABI = [
    "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable",
    "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
    "function getClaimConditionById(uint256 _tokenId,uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata))",
    "function uri(uint256) view returns (string)"
  ];
  const ERC20_ABI = [
    "function approve(address spender,uint256 amount) returns (bool)",
    "function allowance(address owner,address spender) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function balanceOf(address) view returns (uint256)",
    "function symbol() view returns (string)"
  ];

  // ------------ DOM ------------
  // DOM Elements
  const connectBtn = document.getElementById('connectBtn');
  const walletInfo = document.getElementById('walletInfo');
  const walletAddress = document.getElementById('walletAddress');
  const networkName = document.getElementById('networkName');
  const balanceAmount = document.getElementById('balanceAmount');
  const balanceCurrency = document.getElementById('balanceCurrency');
  const connStatus = document.getElementById('connStatus');

  // Web3 Variables
  let provider, signer, userAddress;

  // ------------ WALLET CONNECTION ------------
  async function connectWallet() {
    try {
      if (!window.ethereum) {
        throw new Error('MetaMask not detected. Please install MetaMask first.');
      }

      connectBtn.disabled = true;
      connectBtn.classList.add('loading');
      connStatus.textContent = 'Connecting to MetaMask...';
      connStatus.className = 'status warning';

      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      userAddress = accounts[0];
      
      provider = new ethers.providers.Web3Provider(window.ethereum);
      signer = provider.getSigner();

      await checkNetwork();

      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleChainChanged);

      updateWalletUI();
      connStatus.textContent = 'Connected to MetaMask';
      connStatus.className = 'status success';

      initializeNFTData();
      
    } catch (error) {
      console.error('Connection error:', error);
      connStatus.textContent = error.message;
      connStatus.className = 'status error';
      connectBtn.disabled = false;
      connectBtn.classList.remove('loading');
    }
  }

  async function checkNetwork() {
    const network = await provider.getNetwork();
    const networkIndicator = document.querySelector('.network-indicator');
    
    if (network.chainId === BSC_CHAIN_ID) {
      networkName.textContent = 'BSC';
      networkIndicator.className = 'network-indicator valid';
      return true;
    } else {
      networkName.textContent = `Chain ${network.chainId}`;
      networkIndicator.className = 'network-indicator invalid';
      throw new Error(`Please switch to Binance Smart Chain (Chain ID: ${BSC_CHAIN_ID})`);
    }
  }

  async function switchNetwork() {
    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: `0x${BSC_CHAIN_ID.toString(16)}` }],
      });
      return true;
    } catch (switchError) {
      if (switchError.code === 4902) {
        try {
          await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: `0x${BSC_CHAIN_ID.toString(16)}`,
              chainName: 'Binance Smart Chain',
              nativeCurrency: {
                name: 'BNB',
                symbol: 'BNB',
                decimals: 18
              },
              rpcUrls: ['https://bsc-dataseed.binance.org/'],
              blockExplorerUrls: ['https://bscscan.com/']
            }]
          });
          return true;
        } catch (addError) {
          throw new Error('Failed to add BSC network to MetaMask');
        }
      }
      throw new Error('Failed to switch to BSC network');
    }
  }

  function updateWalletUI() {
    connectBtn.textContent = 'Connected';
    walletInfo.style.display = 'flex';
    walletAddress.textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
    updateBalance();
  }

  async function updateBalance() {
    if (!provider || !userAddress) return;
    
    try {
      const balance = await provider.getBalance(userAddress);
      balanceAmount.textContent = parseFloat(ethers.utils.formatEther(balance)).toFixed(4);
      balanceCurrency.textContent = 'BNB';
    } catch (error) {
      console.error('Error fetching balance:', error);
    }
  }

  function handleAccountsChanged(accounts) {
    if (accounts.length === 0) {
      disconnectWallet();
    } else if (accounts[0] !== userAddress) {
      userAddress = accounts[0];
      walletAddress.textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
      updateBalance();
    }
  }

  function handleChainChanged(chainId) {
    window.location.reload();
  }

  function disconnectWallet() {
    userAddress = null;
    provider = null;
    signer = null;
    connectBtn.textContent = 'Connect MetaMask';
    walletInfo.style.display = 'none';
    connStatus.textContent = '';
    connectBtn.disabled = false;
    connectBtn.classList.remove('loading');
  }

  // ------------ Helpers ------------
  async function load1155Meta(contractAddr, tokenId) {
    const c = new ethers.Contract(contractAddr, DROP1155_ABI, readProvider());
    const base = await c.uri(tokenId);
    const url = base.includes("{id}") ? base.replace("{id}", idToHex(tokenId)) : base;
    return fetchJsonWithFallback(ipfsToHttp(url));
  }

  function ipfsToHttp(u){ return ipfsHttp(u); }

  async function fetchJson(url){
    const r = await fetch(url); 
    if(!r.ok) throw new Error("Failed to fetch "+url);
    return r.json();
  }

  async function readClaim(contractAddr, tokenId){
    const c = new ethers.Contract(contractAddr, DROP1155_ABI, readProvider());
    const condId = await c.getActiveClaimConditionId(tokenId);
    const cond = await c.getClaimConditionById(tokenId, condId);
    return {
      // indexes per ABI
      max: cond[1],
      claimed: cond[2],
      quantityLimitPerWallet: cond[3],
      pricePerToken: cond[5],
      currency: cond[6],
    };
  }

  function fmtEth(wei){ return ethers.utils.formatEther(wei); }
  function toWei(s){ return ethers.utils.parseEther(s); }

  function setStatus(element, type, message) {
    element.textContent = message;
    element.className = "status " + (type||"");
  }

  async function updateBalances() {
    if (!userAddr || !ethersProvider) return;
    try {
      const bnbBalance = await ethersProvider.getBalance(userAddr);
      balanceAmount.textContent = parseFloat(fmtEth(bnbBalance)).toFixed(4);
      balanceCurrency.textContent = "BNB";
      mechs.balance.textContent = `${parseFloat(fmtEth(bnbBalance)).toFixed(4)} BNB`;

      // KLY ERC-20
      const kly = new ethers.Contract(KLY_TOKEN, ERC20_ABI, readProvider());
      const [klyBal, klyDec, klySym] = await Promise.all([
        kly.balanceOf(userAddr),
        kly.decimals(),
        kly.symbol()
      ]);
      crypt.balance.textContent = `${parseFloat(ethers.utils.formatUnits(klyBal, klyDec)).toFixed(2)} ${klySym}`;
    } catch (e) {
      console.error("Error updating balances:", e);
    }
  }

  // cache for ERC20 metadata
  const erc20MetaCache = new Map();
  async function getErc20Meta(addr){
    if (erc20MetaCache.has(addr)) return erc20MetaCache.get(addr);
    const k = new ethers.Contract(addr, ERC20_ABI, readProvider());
    const [dec, sym] = await Promise.all([k.decimals(), k.symbol()]);
    const meta = {decimals: dec, symbol: sym};
    erc20MetaCache.set(addr, meta);
    return meta;
  }

  // ------------ Render Previews ------------
  async function renderMech(){
    const id = Number(mechs.sel.value);
    const entry = MECHS.find(x=>x.id===id);
    mechs.name.textContent = entry?.name || `Token #${id}`;
    mechs.img.src = "";
    mechs.img.alt = "Preview";

    // loading UI
    [mechs.img, mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.add("loading"));

    // image
    try {
      const meta = entry?.uri ? await fetchJsonWithFallback(ipfsToHttp(entry.uri)) : await load1155Meta(CONTRACT_MECHS, id);
      const imgCandidates = meta.image || meta.image_url || meta.imageUri || "";
      // try 3 gateways if image fails
      let gatewayTry = 0;
      function setNext(){
        mechs.img.src = ipfsHttp(imgCandidates, gatewayTry++);
      }
      mechs.img.onerror = ()=>{ if (gatewayTry<3) setNext(); };
      setNext();
    } catch(e) { 
      console.error("Error loading mech preview:", e);
      mechs.img.alt = "Preview unavailable"; 
    } finally {
      mechs.img.classList.remove("loading");
    }

    // price & supply
    try {
      const claim = await readClaim(CONTRACT_MECHS, id);
      const isNative = (claim.currency === ethers.constants.AddressZero);
      const onChainPrice = claim.pricePerToken;
      const price = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : onChainPrice;

      mechs.price.textContent = `${fmtEth(price)} BNB`;
      mechs.currency.textContent = isNative ? "BNB" : "ERC20";
      mechs.supply.textContent = `${claim.claimed.toString()} / ${claim.max.toString()}`;

      // clamp quantity to wallet limit if any (>0)
      const maxPerWallet = ethers.BigNumber.from(claim.quantityLimitPerWallet || 0);
      const currentQty = Math.max(1, Number(mechs.qty.value) || 1);
      const clamped = maxPerWallet.gt(0) ? Math.min(currentQty, maxPerWallet.toNumber()) : currentQty;
      if (clamped !== currentQty){
        mechs.qty.value = clamped;
        setStatus(mechs.status, "warning", `Clamped to wallet limit: ${clamped}`);
      } else {
        setStatus(mechs.status, "", "");
      }

      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      const total = price.mul(qty);
      mechs.mint.textContent = `Mint for ${parseFloat(fmtEth(total)).toFixed(4)} BNB (est.)`;
    } catch(e) { 
      console.error("Error loading mech price:", e);
      mechs.price.textContent="—"; 
      mechs.currency.textContent="—"; 
      mechs.supply.textContent="—";
      mechs.mint.textContent = "Mint Mech";
    } finally {
      [mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.remove("loading"));
    }
  }

  async function renderCryptid(){
    const id = Number(crypt.sel.value);
    const entry = CRYPTIDS.find(x=>x.id===id);
    crypt.name.textContent = entry?.name || `Token #${id}`;
    crypt.img.src = "";
    crypt.img.alt = "Preview";

    [crypt.img, crypt.price, crypt.currency, crypt.supply].forEach(el=>el.classList.add("loading"));

    try {
      const meta = entry?.uri ? await fetchJsonWithFallback(ipfsToHttp(entry.uri)) : await load1155Meta(CONTRACT_CRYPTIDS, id);
      const imgCandidates = meta.image || meta.image_url || meta.imageUri || "";
      let gatewayTry = 0;
      function setNext(){
        crypt.img.src = ipfsHttp(imgCandidates, gatewayTry++);
      }
      crypt.img.onerror = ()=>{ if (gatewayTry<3) setNext(); };
      setNext();
    } catch(e) { 
      console.error("Error loading cryptid preview:", e);
      crypt.img.alt = "Preview unavailable"; 
    } finally {
      crypt.img.classList.remove("loading");
    }

    try {
      const claim = await readClaim(CONTRACT_CRYPTIDS, id);
      const erc20Addr = claim.currency;
      const meta = await getErc20Meta(erc20Addr || KLY_TOKEN); // fallback to known KLY
      const price = FORCED_CRYPTIDS_PRICE_KLY
        ? ethers.utils.parseUnits(FORCED_CRYPTIDS_PRICE_KLY, meta.decimals)
        : claim.pricePerToken;

      crypt.price.textContent = `${ethers.utils.formatUnits(price, meta.decimals)} ${meta.symbol}`;
      crypt.currency.textContent = meta.symbol;
      crypt.supply.textContent = `${claim.claimed.toString()} / ${claim.max.toString()}`;

      const maxPerWallet = ethers.BigNumber.from(claim.quantityLimitPerWallet || 0);
      const currentQty = Math.max(1, Number(crypt.qty.value) || 1);
      const clamped = maxPerWallet.gt(0) ? Math.min(currentQty, maxPerWallet.toNumber()) : currentQty;
      if (clamped !== currentQty){
        crypt.qty.value = clamped;
        setStatus(crypt.status, "warning", `Clamped to wallet limit: ${clamped}`);
      } else {
        setStatus(crypt.status, "", "");
      }

      const qty = Math.max(1, Number(crypt.qty.value) || 1);
      const total = price.mul(qty);
      crypt.mint.textContent = `Mint for ${parseFloat(ethers.utils.formatUnits(total, meta.decimals)).toFixed(2)} ${meta.symbol} (est.)`;
    } catch(e) { 
      console.error("Error loading cryptid price:", e);
      crypt.price.textContent="—"; 
      crypt.currency.textContent="—"; 
      crypt.supply.textContent="—";
      crypt.mint.textContent = "Mint Cryptid";
    } finally {
      [crypt.price, crypt.currency, crypt.supply].forEach(el=>el.classList.remove("loading"));
    }
  }

  async function refreshAll(){
    try {
      await Promise.all([renderMech(), renderCryptid()]);
      if (userAddr) await updateBalances();
    } catch (e) {
      console.error("Error refreshing data:", e);
    }
  }

  // Events
  mechs.sel.addEventListener("change", renderMech);
  crypt.sel.addEventListener("change", renderCryptid);
  mechs.qty.addEventListener("change", renderMech);
  crypt.qty.addEventListener("change", renderCryptid);

  // ------------ Mint ------------
  function makeAllowlistProof(pricePer, currency){
    // default open claim (no proof)
    return {
      proof: [],
      quantityLimitPerWallet: 0,
      pricePerToken: pricePer,
      currency
    };
  }

  async function mintMech(){
    try {
      if (!signer) { await connect(); if (!signer) return; }

      mechs.mint.disabled = true; 
      mechs.mint.classList.add("loading");
      setStatus(mechs.status, "warning", "Preparing transaction…");

      const tokenId = Number(mechs.sel.value);
      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      const drop = new ethers.Contract(CONTRACT_MECHS, DROP1155_ABI, signer);

      const condId = await drop.getActiveClaimConditionId(tokenId);
      const cond = await drop.getClaimConditionById(tokenId, condId);
      const pricePer = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : cond.pricePerToken;
      const totalValue = pricePer.mul(qty);

      // balance check
      const userBalance = await ethersProvider.getBalance(userAddr);
      if (userBalance.lt(totalValue)) {
        throw new Error(`Insufficient BNB balance. Needed: ${fmtEth(totalValue)}, have: ${fmtEth(userBalance)}`);
      }

      // final button price refresh
      mechs.mint.textContent = `Mint for ${parseFloat(fmtEth(totalValue)).toFixed(4)} BNB`;

      const allowlist = makeAllowlistProof(pricePer, ethers.constants.AddressZero);
      const tx = await drop.claim(
        userAddr,
        tokenId,
        qty,
        ethers.constants.AddressZero,
        pricePer,
        allowlist,
        "0x",
        { value: totalValue }
      );

      setStatus(mechs.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(mechs.status, "success", `Minted! Tx: ${rec.transactionHash.slice(0,10)}…`);
      await refreshAll();
    } catch(e){
      console.error(e);
      const msg = (e && (e.data?.message || e.error?.message || e.message)) || "Transaction failed";
      setStatus(mechs.status, "error", msg);
    } finally {
      mechs.mint.disabled = false;
      mechs.mint.classList.remove("loading");
    }
  }

  async function mintCryptid(){
    try {
      if (!signer) { await connect(); if (!signer) return; }

      crypt.mint.disabled = true; 
      crypt.mint.classList.add("loading");
      setStatus(crypt.status, "warning", "Preparing transaction…");

      const tokenId = Number(crypt.sel.value);
      const qty = Math.max(1, Number(crypt.qty.value) || 1);
      const drop = new ethers.Contract(CONTRACT_CRYPTIDS, DROP1155_ABI, signer);

      const condId = await drop.getActiveClaimConditionId(tokenId);
      const cond = await drop.getClaimConditionById(tokenId, condId);

      // currency + price (ERC20)
      const erc20Addr = cond.currency || KLY_TOKEN;
      const erc20 = new ethers.Contract(erc20Addr, ERC20_ABI, signer);
      const meta = await getErc20Meta(erc20Addr);
      const pricePer = FORCED_CRYPTIDS_PRICE_KLY
        ? ethers.utils.parseUnits(FORCED_CRYPTIDS_PRICE_KLY, meta.decimals)
        : cond.pricePerToken;
      const total = pricePer.mul(qty);

      // balance/allowance checks
      const [bal, allowance] = await Promise.all([
        erc20.balanceOf(userAddr),
        erc20.allowance(userAddr, CONTRACT_CRYPTIDS)
      ]);
      if (bal.lt(total)){
        throw new Error(`Insufficient ${meta.symbol}. Need ${ethers.utils.formatUnits(total, meta.decimals)} ${meta.symbol}.`);
      }
      if (allowance.lt(total)){
        setStatus(crypt.status, "warning", `Approving ${meta.symbol}…`);
        const txA = await erc20.approve(CONTRACT_CRYPTIDS, total);
        await txA.wait();
      }

      // final button text
      crypt.mint.textContent = `Minting…`;

      const allowlist = makeAllowlistProof(pricePer, erc20Addr);
      const tx = await drop.claim(
        userAddr,
        tokenId,
        qty,
        erc20Addr,
        pricePer,
        allowlist,
        "0x"
      );

      setStatus(crypt.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(crypt.status, "success", `Minted! Tx: ${rec.transactionHash.slice(0,10)}…`);
      await refreshAll();
    } catch(e){
      console.error(e);
      const msg = (e && (e.data?.message || e.error?.message || e.message)) || "Transaction failed";
      setStatus(crypt.status, "error", msg);
    } finally {
      crypt.mint.disabled = false;
      crypt.mint.classList.remove("loading");
    }
  }

  mechs.mint.addEventListener("click", mintMech);
  crypt.mint.addEventListener("click", mintCryptid);

  // ------------ Boot ------------
  initWeb3Modal();
  connectBtn.addEventListener("click", connect);
  refreshAll();
</script>
</body>
</html>
