<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mint Exclusive & Rare NFTs | Tamaquah Nation</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
<style>
  :root {
    --bg: #0A1A24;
    --bg2: #051018;
    --ink: #EAF7FF;
    --sub: #9CCBE3;
    --accent: #73E1FF;
    --gold: #e2c675;
    --metamask: #f6851b;
    --card: rgba(255,255,255,.06);
    --stroke: rgba(255,255,255,.12);
    --glow: 0 0 24px rgba(115,225,255,.35);
    --success: #4ade80;
    --error: #f87171;
    --warning: #fbbf24;
  }
  
  html, body {
    margin: 0;
    background: linear-gradient(180deg, var(--bg), var(--bg2));
    color: var(--ink);
    font-family: 'Inter', system-ui, Arial, sans-serif;
    min-height: 100vh;
  }
  
  .wrap {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }
  
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }
  
  .brand {
    font-weight: 800;
    letter-spacing: .08em;
    font-size: 1.5rem;
    color: var(--accent);
    text-shadow: 0 0 10px rgba(115,225,255,0.3);
  }
  
  .hero {
    text-align: center;
    padding: 2rem 0;
    margin-bottom: 3rem;
  }
  
  .hero h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    margin: 0 0 1rem;
    text-transform: uppercase;
    letter-spacing: .06em;
    background: linear-gradient(90deg, var(--accent), var(--gold));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  .hero p {
    color: var(--sub);
    margin: 0;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
    font-size: 1.1rem;
  }
  
  .wallet-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
  }
  
  .btn {
    background: linear-gradient(90deg, var(--metamask), #f8a34d);
    color: white;
    border: none;
    border-radius: 12px;
    padding: 1rem 2rem;
    font-weight: 700;
    cursor: pointer;
    transition: all .2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  
  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(246, 133, 27, 0.3);
  }
  
  .btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none !important;
  }
  
  .wallet-info {
    display: flex;
    gap: 1rem;
    align-items: center;
    background: rgba(0,0,0,0.2);
    padding: 0.75rem 1.5rem;
    border-radius: 999px;
    font-size: 0.95rem;
  }
  
  .wallet-address {
    font-family: monospace;
    font-size: 0.9rem;
  }
  
  .balance {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }
  
  .balance-amount {
    font-weight: 600;
  }
  
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-top: 2rem;
  }
  
  .card {
    background: var(--card);
    border: 1px solid var(--stroke);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 16px 60px rgba(0,0,0,.35);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  
  .card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, var(--accent), var(--gold));
  }
  
  .card:hover {
    transform: translateY(-8px);
    box-shadow: 0 20px 80px rgba(0,0,0,0.5);
    border-color: rgba(115,225,255,0.3);
  }
  
  .card h2 {
    margin: 0 0 1rem;
    font-size: 1.5rem;
  }
  
  .contract-address {
    font-size: 0.85rem;
    word-break: break-all;
    color: var(--sub);
    margin-bottom: 1rem;
    display: block;
  }
  
  .form-group {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    margin: 1rem 0;
  }
  
  label {
    font-size: 0.95rem;
    opacity: 0.9;
  }
  
  select, input[type=number] {
    background: #0c1d27;
    color: var(--ink);
    border: 1px solid var(--stroke);
    border-radius: 10px;
    padding: 0.75rem 1rem;
    font-family: inherit;
    transition: all 0.2s ease;
    min-width: 100px;
  }
  
  select:hover, input[type=number]:hover {
    border-color: var(--accent);
  }
  
  select:focus, input[type=number]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(115,225,255,0.2);
  }
  
  .preview {
    display: flex;
    gap: 1.5rem;
    margin: 1.5rem 0;
    align-items: flex-start;
  }
  
  .preview img {
    width: 180px;
    height: 180px;
    object-fit: cover;
    border-radius: 12px;
    border: 1px solid var(--stroke);
    box-shadow: 0 20px 60px rgba(0,0,0,.35);
    transition: all 0.3s ease;
    background: linear-gradient(45deg, #0c1d27, #0a2738);
  }
  
  .preview img:hover {
    transform: scale(1.03);
    box-shadow: 0 20px 80px rgba(0,0,0,0.6);
  }
  
  .meta {
    flex: 1;
  }
  
  .nft-name {
    margin: 0 0 0.5rem;
    font-size: 1.25rem;
  }
  
  .stat {
    display: flex;
    justify-content: space-between;
    margin: 0.5rem 0;
    font-size: 0.95rem;
  }
  
  .stat-label {
    color: var(--sub);
  }
  
  .stat-value {
    font-weight: 600;
  }
  
  .mint-btn {
    background: linear-gradient(90deg, var(--accent), #a9ffcb);
    color: #001018;
    border: none;
    border-radius: 12px;
    padding: 1rem 1.5rem;
    font-weight: 700;
    cursor: pointer;
    width: 100%;
    margin-top: 1rem;
    transition: all 0.2s ease;
  }
  
  .mint-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 32px rgba(115,225,255,0.5);
  }
  
  .status {
    min-height: 24px;
    font-size: 0.9rem;
    margin-top: 0.5rem;
    text-align: center;
  }
  
  .status.success {
    color: var(--success);
  }
  
  .status.error {
    color: var(--error);
  }
  
  .status.warning {
    color: var(--warning);
  }
  
  .loading {
    position: relative;
    color: transparent !important;
  }
  
  .loading:after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.2);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }
  
  footer {
    margin-top: 3rem;
    text-align: center;
    color: var(--sub);
    font-size: 0.9rem;
    padding: 1rem;
  }
  
  /* Network indicator */
  .network-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
    padding: 0.5rem 1rem;
    border-radius: 999px;
    background: rgba(0,0,0,0.2);
  }
  
  .network-indicator.valid {
    background: rgba(74, 222, 128, 0.1);
    color: var(--success);
  }
  
  .network-indicator.invalid {
    background: rgba(248, 113, 113, 0.1);
    color: var(--error);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .wrap {
      padding: 1.5rem;
    }
    
    .grid {
      grid-template-columns: 1fr;
    }
    
    .preview {
      flex-direction: column;
    }
    
    .preview img {
      width: 100%;
      height: auto;
      max-height: 300px;
    }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">TAMAQUAH VAULT</div>
  </header>

  <section class="hero">
    <h1>Mint Exclusive & Rare NFTs</h1>
    <p>Connect your MetaMask wallet to mint these unique digital artifacts from our collections.</p>
  </section>

  <div class="wallet-section">
    <button id="connectBtn" class="btn">
      <svg width="20" height="20" viewBox="0 0 40 37" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M36.0115 3.33203L22.2221 14.2493C21.2623 14.9929 19.7377 14.9929 18.7779 14.2493L4.9885 3.33203" stroke="white" stroke-width="6" stroke-linecap="round"/>
        <path d="M26.2086 23.5947L23.3333 26.0413C21.4609 27.6545 18.5391 27.6545 16.6667 26.0413L13.7914 23.5947" stroke="white" stroke-width="6" stroke-linecap="round"/>
        <rect x="1" y="1" width="38" height="35" rx="6" stroke="white" stroke-width="2"/>
      </svg>
      Connect MetaMask
    </button>
    
    <div id="walletInfo" style="display: none;">
      <div class="wallet-info">
        <span id="walletAddress" class="wallet-address"></span>
        <span class="network-indicator">
          <span id="networkName">BSC</span>
        </span>
      </div>
      <div class="wallet-info">
        <span class="balance">
          Balance: <span id="balanceAmount" class="balance-amount">0</span>
          <span id="balanceCurrency">BNB</span>
        </span>
      </div>
    </div>
    
    <div id="connStatus" class="status"></div>
  </div>

  <section class="grid">
    <!-- Ancestral Mechs (BNB) -->
    <div class="card" id="mechsCard">
      <h2>Ancestral Mechs: Bloodline Codex</h2>
      <span class="contract-address">Contract: 0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989</span>
      
      <div class="form-group">
        <label for="mechsTokenId">Token ID</label>
        <select id="mechsTokenId"></select>
        <label for="mechsQty">Quantity</label>
        <input id="mechsQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="mechsImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="mechsName" class="nft-name">—</h3>
          <div class="stat">
            <span class="stat-label">Price/Token:</span>
            <span id="mechsPrice" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Currency:</span>
            <span id="mechsCurrency" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Supply:</span>
            <span id="mechsSupply" class="stat-value">—</span>
          </div>
          <div class="stat">
            <span class="stat-label">Your Balance:</span>
            <span id="mechsBalance" class="stat-value">—</span>
          </div>
        </div>
      </div>

      <button id="mechsMint" class="mint-btn">Mint Mech</button>
      <div id="mechsStatus" class="status"></div>
    </div>

    <!-- Tribal Punk Cryptids (KLY) -->
    <div class="card" id="cryptidsCard">
      <h2>Tribal Punk Cryptids</h2>
      <span class="contract-address">Contract: 0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11</span>
      
      <div class="form-group">
        <label for="cryptidTokenId">Token ID</label>
        <select id="cryptidTokenId"></select>
        <label for="cryptidQty">Quantity</label>
        <input id="cryptidQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="cryptidImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="cryptidName" class="nft-name">—</h3>
          <div class="stat">
            <span class="stat-label">Price/Token:</span>
            <span id="cryptidPrice" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Currency:</span>
            <span id="cryptidCurrency" class="stat-value">loading…</span>
          </div>
          <div class="stat">
            <span class="stat-label">Supply:</span>
            <span id="cryptidSupply" class="stat-value">—</span>
          </div>
          <div class="stat">
            <span class="stat-label">Your Balance:</span>
            <span id="cryptidBalance" class="stat-value">—</span>
          </div>
        </div>
      </div>

      <button id="cryptidMint" class="mint-btn">Mint Cryptid</button>
      <div id="cryptidStatus" class="status"></div>
    </div>
  </section>

  <footer>They took the land. We took the future.</footer>
</div>
<script type="module">
  // ------------ CONFIG ------------
  const BSC_CHAIN_ID = 56;
  const CONTRACT_MECHS    = "0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989";
  const CONTRACT_CRYPTIDS = "0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11";
  const KLY_TOKEN         = "0x2e4fEB2Fe668c8Ebe84f19e6c8fE8Cf8131B4E52"; // ERC-20 (on BSC)

  const FORCED_MECHS_PRICE_BNB = "0.0063"; // or null
  const FORCED_CRYPTIDS_PRICE_KLY = null;  // or "12.34"

  const READ_RPC = "https://bsc-dataseed.binance.org/";

  // ------------ TOKEN LISTS ------------
  const T = (id, name, uri)=>({id, name, uri});
  const CRYPTIDS = [
    T(0,"Wendigo.EXE","ipfs://QmV2X7oUrG5i284sKQPHQJAbQV8HkL788mbZexuCA5oTvx/0"),
    T(1,"Mask of Memory","ipfs://Qmbu7rbrAoG3cJTYEJGGJ6iZsPGpDQxhkJBsKt4QuBJj8N/0"),
    T(2,"Wolf of Wounded Knee","ipfs://QmQm8nSAL56mGypS45f4AZ44xejVPWuktWidfZqAHdJtmk/0"),
    T(3,"Coastal Sasquatch Punk","ipfs://QmV91qcvQmzwUEu4hin91iXqzVn7hn1F9gZ9bmfxnFTQje/0"),
    T(4,"Anishinaabe Wendigo Protocol","ipfs://QmStEaLkFwNREJ3M4t42hNKvphwjHK1MxjA7CUdW15d6BE/0"),
    T(5,"Desert Skinwalker Punk","ipfs://QmcW6m3B1ygPoMrsr4qVMaNC4uCL1s4EAq2LcdEsCj6iUS/0"),
    T(6,"Métis Rougarou Rider","ipfs://Qmeg78oUMrM1fUGNMVzUNG2G5dEDuD8TLoB9Mh3j3X6zEF/0"),
    T(7,"Cherokee Skinwalker Firewall","ipfs://QmWNsSbcy2iBmYjK2TCzELZTfzD1ezGj1WvktYiwnWnjjg/0"),
    T(8,"Wabanaki Webworm","ipfs://QmdadZMbe1QMUW5i51smLxEDuWvRWKanLiiHdyb4zH2mbM/0"),
    T(9,"Deer Woman DAO","ipfs://QmTmrUDMXuqnffe1duAEYdJGAKNeSdEsVvKe8dT8YKR4i7/0"),
    T(10,"The Cipherskin Codex","ipfs://QmPcWyNf93hwKXxBH5QpseeqmkE296arM1jkg4zcvi3bgC/0"),
    T(11,"Treaty.Exe","ipfs://QmeGbsj4E3w9zaaEnQiSsDUrPUbbTWumn8BemBnsHNdFuR/0"),
    T(12,"Scroll of Unburied Seeds","ipfs://QmNXhjcuNvaYDW7PdDi7Erh1jbkhQb6ep15FAYcXVZUByE/0"),
    T(13,"The Disentrancer","ipfs://QmQP3hP9YyAkFZwKNkrw5apxEcZ7nAZecshsaE1sdpyGaz/0"),
    T(14,"Ledger Shaman","ipfs://QmNj8tHVjp4X1HNBFbm4nbw6mb2vzdMHrYDd8wQuE35qFw/0"),
    T(15,"The Ghost of Paper Genocide","ipfs://QmWbTfxSn4Mybnw3deUiFn3T8PVyyJkiCPZD9C91Sqz9Kk/0"),
    T(16,"Ironroot Codewalker","ipfs://QmWMhG22wfXFZufu7E2haVkqoc1XYf4bU8KXvVL6xUZZXW/0"),
    T(17,"Deer Woman 9.0","ipfs://QmRieQJ4gpkjMsJkaB99t2M5BX5sns6CWVJPa3HNwASCEB/0"),
    T(18,"Thunderbird 9G","ipfs://QmPnk3rYUeqeCevm7pjjfp31WrsUp8CzBP96TVRmmFky7h/0"),
    T(19,"Skinwalker 9S","ipfs://Qmbv4hEy6gW68XSUUW46nzYmptaxiWS1vFGig3457W1Wez/0"),
  ];
  const MECHS = [ T(0,"Skybone Leviathan","ipfs://QmXZaUkWziGrd2ooyXdQavJmPXCtWFjZrGL9239n4Nu7yU/0") ];

  // ------------ ABIs ------------
  const DROP1155_ABI = [
    "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable",
    "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
    "function getClaimConditionById(uint256 _tokenId,uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata))",
    "function uri(uint256) view returns (string)"
  ];
  const ERC20_ABI = [
    "function approve(address spender,uint256 amount) returns (bool)",
    "function allowance(address owner,address spender) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function balanceOf(address) view returns (uint256)",
    "function symbol() view returns (string)"
  ];

  // ------------ DOM ------------
  const connectBtn = document.getElementById('connectBtn');
  const walletInfo = document.getElementById('walletInfo');
  const walletAddress = document.getElementById('walletAddress');
  const networkName = document.getElementById('networkName');
  const balanceAmount = document.getElementById('balanceAmount');
  const balanceCurrency = document.getElementById('balanceCurrency');
  const connStatus = document.getElementById('connStatus');

  // groups used below
  const mechs = {
    sel: document.getElementById("mechsTokenId"), qty: document.getElementById("mechsQty"),
    img: document.getElementById("mechsImg"), name: document.getElementById("mechsName"),
    price: document.getElementById("mechsPrice"), currency: document.getElementById("mechsCurrency"),
    supply: document.getElementById("mechsSupply"), balance: document.getElementById("mechsBalance"),
    mint: document.getElementById("mechsMint"), status: document.getElementById("mechsStatus")
  };
  const crypt = {
    sel: document.getElementById("cryptidTokenId"), qty: document.getElementById("cryptidQty"),
    img: document.getElementById("cryptidImg"), name: document.getElementById("cryptidName"),
    price: document.getElementById("cryptidPrice"), currency: document.getElementById("cryptidCurrency"),
    supply: document.getElementById("cryptidSupply"), balance: document.getElementById("cryptidBalance"),
    mint: document.getElementById("cryptidMint"), status: document.getElementById("cryptidStatus")
  };

  // ------------ Providers / State (ethers v6) ------------
  const readProvider = new ethers.JsonRpcProvider(READ_RPC);
  let browserProvider = null; // ethers.BrowserProvider
  let signer = null;
  let userAddr = null;

  // ------------ Utils ------------
  const shorten = a => a ? `${a.slice(0,6)}…${a.slice(-4)}` : "—";
  function setStatus(elOrType, typeOrMsg, maybeMsg){
    // setStatus(element, type, message) OR setStatus(type, message)
    let el, type, msg;
    if (typeof elOrType === 'string'){ el = connStatus; type = elOrType; msg = typeOrMsg || ''; }
    else { el = elOrType || connStatus; type = typeOrMsg || ''; msg = maybeMsg || ''; }
    el.textContent = msg; el.className = "status " + (type||"");
  }
  const idToHex = n => n.toString(16).padStart(64,"0");
  function ipfsHttp(url, gatewayIndex=0){
    if (!url) return "";
    if (!url.startsWith("ipfs://")) return url;
    const p = url.slice(7);
    const gws = ["https://ipfs.io/ipfs/","https://cloudflare-ipfs.com/ipfs/","https://gateway.pinata.cloud/ipfs/"];
    return gws[Math.min(gatewayIndex,gws.length-1)] + p;
  }
  async function fetchJsonWithFallback(ipfsUrl){
    let lastErr;
    for (let i=0;i<3;i++){
      try{
        const r = await fetch(ipfsHttp(ipfsUrl,i));
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      }catch(e){ lastErr = e; }
    }
    throw lastErr || new Error("Fetch failed");
  }
  const ZERO = ethers.ZeroAddress;
  const fmtEth = v => ethers.formatEther(v);
  const toWei  = s => ethers.parseEther(s);
  const fmtU   = (v,d)=> ethers.formatUnits(v,d);
  const toU    = (s,d)=> ethers.parseUnits(s,d);
  const trimEther = (s,dec=4)=>{ const [i,f='']=String(s).split('.'); return f?`${i}.${f.slice(0,dec)}`:`${i}.${'0'.repeat(dec)}`; };

  // ------------ WALLET CONNECTION ------------
  async function connectWallet(){
    try{
      if (!window.ethereum) throw new Error('MetaMask not detected. Please install MetaMask first.');
      connectBtn.disabled = true; connectBtn.classList.add('loading');
      setStatus('warning','Connecting to MetaMask…');

      browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
      await browserProvider.send('eth_requestAccounts',[]);
      await ensureCorrectNetwork(BSC_CHAIN_ID);

      signer = await browserProvider.getSigner();
      userAddr = await signer.getAddress();

      window.ethereum.on?.('accountsChanged', handleAccountsChanged);
      window.ethereum.on?.('chainChanged', handleChainChanged);

      connectBtn.textContent = 'Connected';
      walletInfo.style.display = 'flex';
      walletAddress.textContent = shorten(userAddr);
      await updateNetworkIndicator();
      await updateBalance();
      await refreshAll();

      setStatus('success','Connected to MetaMask');
    } catch(e){
      console.error(e);
      setStatus('error', e?.message || 'Connection failed');
      connectBtn.disabled = false; connectBtn.classList.remove('loading');
    }
  }
  async function ensureCorrectNetwork(required){
    const net = await browserProvider.getNetwork();
    if (Number(net.chainId) === required) return true;
    try{
      await browserProvider.send('wallet_switchEthereumChain',[{ chainId:'0x'+required.toString(16) }]);
    }catch(err){
      if (err?.code === 4902){
        await browserProvider.send('wallet_addEthereumChain',[{
          chainId:'0x'+required.toString(16),
          chainName:'Binance Smart Chain',
          nativeCurrency:{ name:'BNB', symbol:'BNB', decimals:18 },
          rpcUrls:['https://bsc-dataseed1.bnbchain.org','https://bsc-dataseed2.bnbchain.org','https://bsc-dataseed.binance.org'],
          blockExplorerUrls:['https://bscscan.com/']
        }]);
      } else throw err;
    }
    return true;
  }
  function handleAccountsChanged(acc){
    if (!acc?.length) return disconnectWallet();
    userAddr = acc[0];
    walletAddress.textContent = shorten(userAddr);
    updateBalance(); refreshAll();
  }
  function handleChainChanged(){
    if (window.ethereum) browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
    updateNetworkIndicator(); updateBalance(); refreshAll();
  }
  function disconnectWallet(){
    try{
      window.ethereum?.removeListener?.('accountsChanged', handleAccountsChanged);
      window.ethereum?.removeListener?.('chainChanged', handleChainChanged);
    }catch{}
    browserProvider = null; signer = null; userAddr = null;
    connectBtn.textContent = 'Connect MetaMask';
    walletInfo.style.display = 'none';
    connStatus.textContent = '';
    connectBtn.disabled = false; connectBtn.classList.remove('loading');
  }

  /* ==================== Wallet UI helpers ==================== */
  async function updateNetworkIndicator(){
    const indicator = document.querySelector('.network-indicator');
    if (!browserProvider || !indicator) return;
    const net = await browserProvider.getNetwork();
    const cid = Number(net.chainId);
    networkName.textContent = (cid===56?'BSC':`Chain ${cid}`);
    indicator.className = 'network-indicator ' + (cid===BSC_CHAIN_ID ? 'valid' : 'invalid');
  }
  async function updateBalance(){
    if (!browserProvider || !userAddr) return;
    const bal = await browserProvider.getBalance(userAddr);
    balanceAmount.textContent = trimEther(fmtEth(bal),4);
    balanceCurrency.textContent = 'BNB';
  }

  // ------------ Helpers ------------
  async function load1155Meta(contractAddr, tokenId) {
    const c = new ethers.Contract(contractAddr, DROP1155_ABI, readProvider);
    const base = await c.uri(tokenId);
    const url = base.includes("{id}") ? base.replace("{id}", idToHex(tokenId)) : base;
    return fetchJsonWithFallback(url);
  }
 async function readClaim(contractAddr, tokenId){
  const c = new ethers.Contract(contractAddr, DROP1155_ABI, readProvider);
  const condId = await c.getActiveClaimConditionId(tokenId);
  const cond = await c.getClaimConditionById(tokenId, condId);

  let pricePerToken = cond[5];
  let currency      = cond[6];

  // self-heal if ABI order differs
  if (isAddrLike(pricePerToken) && isUintLike(currency)) {
    [pricePerToken, currency] = [currency, pricePerToken];
  }
  if (!isAddrLike(currency)) currency = ethers.ZeroAddress;

  return {
    max: cond[1],
    claimed: cond[2],
    quantityLimitPerWallet: cond[3],
    pricePerToken,
    currency
  };
}
  
  // Put this near your other helpers
const isAddrLike = v => typeof v === 'string' && /^0x[0-9a-fA-F]{40}$/.test(v);
const isUintLike = v => typeof v === 'bigint' || (typeof v === 'object' && 'toString' in v);

  // Balance of both tokens (BNB + KLY)
  async function updateBalances() {
    if (!userAddr || !browserProvider) return;
    try {
      const bnb = await browserProvider.getBalance(userAddr);
      const pretty = trimEther(fmtEth(bnb),4);
      balanceAmount.textContent = pretty;
      balanceCurrency.textContent = "BNB";
      mechs.balance.textContent = `${pretty} BNB`;

      const meta = await getErc20Meta(KLY_TOKEN);
      const kly = new ethers.Contract(KLY_TOKEN, ERC20_ABI, readProvider);
      const kBal = await kly.balanceOf(userAddr);
      crypt.balance.textContent = `${fmtU(kBal, meta.decimals)} ${meta.symbol}`;
    } catch (e) {
      console.error("updateBalances:", e);
    }
  }

  // cache for ERC20 metadata
  const erc20MetaCache = new Map();
  async function getErc20Meta(addr){
    if (erc20MetaCache.has(addr)) return erc20MetaCache.get(addr);
    const k = new ethers.Contract(addr, ERC20_ABI, readProvider);
    const [dec, sym] = await Promise.all([k.decimals(), k.symbol()]);
    const meta = {decimals: Number(dec), symbol: sym};
    erc20MetaCache.set(addr, meta);
    return meta;
  }

  // ------------ Render Previews ------------
  async function renderMech(){
    const id = Number(mechs.sel.value);
    const entry = MECHS.find(x=>x.id===id);
    mechs.name.textContent = entry?.name || `Token #${id}`;
    mechs.img.src = ""; mechs.img.alt = "Preview";
    [mechs.img, mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.add("loading"));

    try {
      const meta = entry?.uri ? await fetchJsonWithFallback(entry.uri) : await load1155Meta(CONTRACT_MECHS, id);
      const img = meta.image || meta.image_url || meta.imageUri || "";
      let i=0; const setNext=()=> mechs.img.src = ipfsHttp(img,i++);
      mechs.img.onerror = ()=>{ if (i<3) setNext(); }; setNext();
    } catch(e) {
      console.error("Mech preview:", e);
      mechs.img.alt = "Preview unavailable";
    } finally {
      mechs.img.classList.remove("loading");
    }

    try {
      const claim = await readClaim(CONTRACT_MECHS, id);
      const isNative = (claim.currency === ZERO);
      const price = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : claim.pricePerToken;

      mechs.price.textContent = `${fmtEth(price)} BNB`;
      mechs.currency.textContent = isNative ? "BNB" : "ERC20";
      mechs.supply.textContent = `${claim.claimed.toString()} / ${claim.max.toString()}`;

      const maxPerWallet = claim.quantityLimitPerWallet ?? 0n;
      const currentQty = Math.max(1, Number(mechs.qty.value) || 1);
      const clamped = (maxPerWallet>0n) ? Math.min(currentQty, Number(maxPerWallet)) : currentQty;
      if (clamped !== currentQty){
        mechs.qty.value = clamped;
        setStatus(mechs.status, "warning", `Clamped to wallet limit: ${clamped}`);
      } else setStatus(mechs.status, "", "");

      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      const total = price * BigInt(qty);
      mechs.mint.textContent = `Mint for ${trimEther(fmtEth(total),4)} BNB (est.)`;
    } catch(e) {
      console.error("Mech price:", e);
      mechs.price.textContent="—"; mechs.currency.textContent="—"; mechs.supply.textContent="—";
      mechs.mint.textContent = "Mint Mech";
    } finally {
      [mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.remove("loading"));
    }
  }

  async function renderCryptid(){
    const id = Number(crypt.sel.value);
    const entry = CRYPTIDS.find(x=>x.id===id);
    crypt.name.textContent = entry?.name || `Token #${id}`;
    crypt.img.src = ""; crypt.img.alt = "Preview";
    [crypt.img, crypt.price, crypt.currency, crypt.supply].forEach(el=>el.classList.add("loading"));

    try {
      const meta = entry?.uri ? await fetchJsonWithFallback(entry.uri) : await load1155Meta(CONTRACT_CRYPTIDS, id);
      const img = meta.image || meta.image_url || meta.imageUri || "";
      let i=0; const setNext=()=> crypt.img.src = ipfsHttp(img,i++);
      crypt.img.onerror = ()=>{ if (i<3) setNext(); }; setNext();
    } catch(e) {
      console.error("Cryptid preview:", e);
      crypt.img.alt = "Preview unavailable";
    } finally {
      crypt.img.classList.remove("loading");
    }

    // Replace the pricing block inside renderMech() with this:
try {
  const claim = await readClaim(CONTRACT_MECHS, id);
  const isNative = (claim.currency === ethers.ZeroAddress);

  if (isNative) {
    const price = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : claim.pricePerToken;
    mechs.currency.textContent = 'BNB';
    mechs.price.textContent = `${trimEther(fmtEth(price),6)} BNB`;
    const qty = Math.max(1, Number(mechs.qty.value) || 1);
    mechs.mint.textContent = `Mint for ${trimEther(fmtEth(price * BigInt(qty)),6)} BNB (est.)`;
  } else {
    const meta = await getErc20Meta(claim.currency);
    mechs.currency.textContent = meta.symbol;
    mechs.price.textContent = `${fmtU(claim.pricePerToken, meta.decimals)} ${meta.symbol}`;
    const qty = Math.max(1, Number(mechs.qty.value) || 1);
    const total = claim.pricePerToken * BigInt(qty);
    mechs.mint.textContent = `Mint for ${fmtU(total, meta.decimals)} ${meta.symbol} (est.)`;
  }

  mechs.supply.textContent = `${claim.claimed.toString()} / ${claim.max.toString()}`;
} catch(e) {
  console.error("Mech price:", e);
  mechs.price.textContent="—"; mechs.currency.textContent="—"; mechs.supply.textContent="—";
  mechs.mint.textContent = "Mint Mech";
}
    
  async function refreshAll(){
    try {
      await Promise.all([renderMech(), renderCryptid()]);
      if (userAddr) await updateBalances();
    } catch (e) {
      console.error("refreshAll:", e);
    }
  }

  // ------------ Mint ------------
  function makeAllowlistProof(pricePer, currency){
    return { proof: [], quantityLimitPerWallet: 0n, pricePerToken: pricePer, currency };
  }

  async function mintMech(){
  try {
    if (!signer) { await connectWallet(); if (!signer) return; }
    mechs.mint.disabled = true; mechs.mint.classList.add("loading");
    setStatus(mechs.status, "warning", "Preparing transaction…");

    const tokenId = Number(mechs.sel.value);
    const qty = Math.max(1, Number(mechs.qty.value) || 1);
    const drop = new ethers.Contract(CONTRACT_MECHS, DROP1155_ABI, signer);

    const claim = await readClaim(CONTRACT_MECHS, tokenId);
    const isNative = (claim.currency === ethers.ZeroAddress);

    let pricePer = claim.pricePerToken;
    let valueOpts = {};
    let currencyAddr = claim.currency;

    if (isNative) {
      // optional UI override
      if (FORCED_MECHS_PRICE_BNB) pricePer = toWei(FORCED_MECHS_PRICE_BNB);
      const totalValue = pricePer * BigInt(qty);
      const userBalance = await browserProvider.getBalance(userAddr);
      if (userBalance < totalValue) throw new Error(`Insufficient BNB. Need ${trimEther(fmtEth(totalValue),6)} BNB.`);
      valueOpts = { value: totalValue };
      currencyAddr = ethers.ZeroAddress;

      // preflight (gets a real revert reason if any)
      const allowlist = makeAllowlistProof(pricePer, currencyAddr);
      await drop.claim.staticCall(userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, "0x", valueOpts);

      mechs.mint.textContent = `Mint for ${trimEther(fmtEth(totalValue),6)} BNB`;
      const tx = await drop.claim(userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, "0x", valueOpts);
      setStatus(mechs.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(mechs.status, "success", `Minted! Tx: ${rec.hash.slice(0,10)}…`);
    } else {
      // ERC‑20 path (in case claim is currently set to a token)
      const meta = await getErc20Meta(currencyAddr);
      const erc20 = new ethers.Contract(currencyAddr, ERC20_ABI, signer);
      const total = pricePer * BigInt(qty);
      const [bal, allowance] = await Promise.all([
        erc20.balanceOf(userAddr),
        erc20.allowance(userAddr, CONTRACT_MECHS)
      ]);
      if (bal < total) throw new Error(`Insufficient ${meta.symbol}. Need ${fmtU(total, meta.decimals)} ${meta.symbol}.`);
      if (allowance < total){
        setStatus(mechs.status, "warning", `Approving ${meta.symbol}…`);
        const txA = await erc20.approve(CONTRACT_MECHS, total);
        await txA.wait();
      }

      const allowlist = makeAllowlistProof(pricePer, currencyAddr);
      // preflight
      await drop.claim.staticCall(userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, "0x");

      const tx = await drop.claim(userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, "0x");
      setStatus(mechs.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(mechs.status, "success", `Minted! Tx: ${rec.hash.slice(0,10)}…`);
    }

    await refreshAll();
  } catch(e){
    const msg = e?.error?.message || e?.info?.error?.message || e?.reason || e?.shortMessage || e?.message || "Transaction failed";
    setStatus(mechs.status, "error", msg);
    console.error('mintMech:', e);
  } finally {
    mechs.mint.disabled = false; mechs.mint.classList.remove("loading");
  }
}
    
  async function mintCryptid(){
    try {
      if (!signer) { await connectWallet(); if (!signer) return; }
      crypt.mint.disabled = true; crypt.mint.classList.add("loading");
      setStatus(crypt.status, "warning", "Preparing transaction…");

      const tokenId = Number(crypt.sel.value);
      const qty = Math.max(1, Number(crypt.qty.value) || 1);
      const drop = new ethers.Contract(CONTRACT_CRYPTIDS, DROP1155_ABI, signer);

      const condId = await drop.getActiveClaimConditionId(tokenId);
      const cond = await drop.getClaimConditionById(tokenId, condId);

      const erc20Addr = cond.currency || KLY_TOKEN;
      const meta = await getErc20Meta(erc20Addr);
      const erc20 = new ethers.Contract(erc20Addr, ERC20_ABI, signer);
      const pricePer = FORCED_CRYPTIDS_PRICE_KLY ? toU(FORCED_CRYPTIDS_PRICE_KLY, meta.decimals) : cond.pricePerToken;
      const total = pricePer * BigInt(qty);

      const [bal, allowance] = await Promise.all([erc20.balanceOf(userAddr), erc20.allowance(userAddr, CONTRACT_CRYPTIDS)]);
      if (bal < total){
        throw new Error(`Insufficient ${meta.symbol}. Need ${fmtU(total, meta.decimals)} ${meta.symbol}.`);
      }
      if (allowance < total){
        setStatus(crypt.status, "warning", `Approving ${meta.symbol}…`);
        const txA = await erc20.approve(CONTRACT_CRYPTIDS, total);
        await txA.wait();
      }

      crypt.mint.textContent = `Minting…`;
      const allowlist = makeAllowlistProof(pricePer, erc20Addr);
      const tx = await drop.claim(userAddr, tokenId, qty, erc20Addr, pricePer, allowlist, "0x");

      setStatus(crypt.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(crypt.status, "success", `Minted! Tx: ${rec.hash.slice(0,10)}…`);
      await refreshAll();
    } catch(e){
      console.error(e);
      const msg = e?.info?.error?.message || e?.shortMessage || e?.message || "Transaction failed";
      setStatus(crypt.status, "error", msg);
    } finally {
      crypt.mint.disabled = false; crypt.mint.classList.remove("loading");
    }
  }

  // ------------ Events ------------
  mechs.sel.addEventListener("change", renderMech);
  crypt.sel.addEventListener("change", renderCryptid);
  mechs.qty.addEventListener("change", renderMech);
  crypt.qty.addEventListener("change", renderCryptid);
  mechs.mint.addEventListener("click", mintMech);
  crypt.mint.addEventListener("click", mintCryptid);
  connectBtn.addEventListener("click", connectWallet);

  // ------------ Boot ------------
  (async function boot(){
    try{
      await refreshAll(); // show read-only data
      if (window.ethereum){
        const acc = await window.ethereum.request({ method:'eth_accounts' });
        if (acc?.length){
          browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
          signer = await browserProvider.getSigner();
          userAddr = acc[0];
          connectBtn.textContent = 'Connected';
          walletInfo.style.display = 'flex';
          walletAddress.textContent = shorten(userAddr);
          await updateNetworkIndicator();
          await updateBalance();
          window.ethereum.on?.('accountsChanged', handleAccountsChanged);
          window.ethereum.on?.('chainChanged', handleChainChanged);
        }
      }
    }catch(e){ console.error(e); }
  })();
</script>
</body>
</html>
