<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mint Exclusive & Rare NFTs | Tamaquah Nation</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3modal@1.9.12/dist/index.js"></script>
<style>
  :root{
    --bg:#0A1A24; --bg2:#051018; --ink:#EAF7FF; --sub:#9CCBE3; --accent:#73E1FF; --gold:#e2c675;
    --card:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12); --glow:0 0 24px rgba(115,225,255,.35);
    --success:#4ade80; --error:#f87171; --warning:#fbbf24;
  }
  html,body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:Inter,system-ui,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:28px 20px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
  .brand{font-weight:800;letter-spacing:.08em;font-size:1.2rem;color:var(--accent)}
  .pill{border:1px solid var(--stroke);padding:6px 10px;border-radius:999px;color:var(--sub);font-size:.85rem;text-decoration:none;transition:all 0.2s ease}
  .pill:hover{background:rgba(255,255,255,0.05);border-color:var(--accent)}
  .hero{text-align:center;padding:10px 0 8px;margin-bottom:24px}
  .hero h1{font-size:clamp(28px,5vw,48px);margin:0 0 8px;text-transform:uppercase;letter-spacing:.06em;background:linear-gradient(90deg, var(--accent), var(--gold));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
  .hero p{color:var(--sub);margin:0;max-width:600px;margin:0 auto;line-height:1.5}
  .bar{display:flex;gap:10px;justify-content:center;margin:16px 0 24px;align-items:center;flex-wrap:wrap}
  .btn{background:linear-gradient(90deg,var(--accent),#a9ffcb);color:#001018;border:0;border-radius:12px;padding:12px 16px;font-weight:800;cursor:pointer;box-shadow:var(--glow);transition:all .15s ease;position:relative;overflow:hidden}
  .btn:hover{transform:translateY(-2px);box-shadow:0 0 32px rgba(115,225,255,0.5)}
  .btn:disabled{opacity:0.7;cursor:not-allowed;transform:none !important}
  .btn.ghost{background:transparent;color:var(--ink);border:1px solid var(--stroke);box-shadow:none}
  .btn.ghost:hover{background:rgba(255,255,255,0.05);border-color:var(--accent)}
  .muted{color:var(--sub);font-size:0.9em}
  .balance{display:flex;gap:6px;align-items:center;background:rgba(0,0,0,0.2);padding:6px 12px;border-radius:999px;font-size:0.9em}
  .balance .currency{color:var(--accent);font-weight:600}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:24px;margin-top:12px}
  @media (max-width:960px){.grid{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--stroke);border-radius:14px;padding:18px;box-shadow:0 16px 60px rgba(0,0,0,.35);transition:all 0.3s ease;position:relative}
  .card:hover{transform:translateY(-4px);box-shadow:0 20px 80px rgba(0,0,0,0.5);border-color:rgba(115,225,255,0.3)}
  .card h2{margin:0 0 8px;font-size:1.4rem}
  .card .contract{font-size:0.85em;word-break:break-all}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0}
  label{opacity:.9;font-size:0.9em}
  select,input[type=number]{background:#0c1d27;color:var(--ink);border:1px solid var(--stroke);border-radius:10px;padding:10px 12px;font-family:inherit;transition:all 0.2s ease}
  select:hover,input[type=number]:hover{border-color:var(--accent)}
  select:focus,input[type=number]:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px rgba(115,225,255,0.2)}
  .stat{display:flex;gap:8px;align-items:center;color:var(--sub);font-size:0.9em}
  .price{font-weight:800;color:var(--ink)}
  .preview{display:flex;gap:14px;margin-top:8px;align-items:flex-start}
  .preview img{width:160px;height:160px;object-fit:cover;border-radius:12px;border:1px solid var(--stroke);box-shadow:0 20px 60px rgba(0,0,0,.35);transition:all 0.3s ease;background:linear-gradient(45deg, #0c1d27, #0a2738)}
  .preview img:hover{transform:scale(1.02);box-shadow:0 20px 80px rgba(0,0,0,0.6)}
  .meta{flex:1}
  h3{margin:0 0 6px;font-size:1.1rem}
  .divider{height:1px;background:var(--stroke);margin:14px 0}
  footer{margin:26px auto 10px;text-align:center;color:var(--sub);font-size:.9rem}
  .status{min-height:24px;font-size:0.9em}
  .status.success{color:var(--success)}
  .status.error{color:var(--error)}
  .status.warning{color:var(--warning)}
  .loading{position:relative;color:transparent !important}
  .loading:after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:16px;height:16px;border:2px solid rgba(255,255,255,0.2);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:translate(-50%,-50%) rotate(360deg)}}
  .tooltip{position:relative;cursor:help}
  .tooltip:after{content:attr(data-tooltip);position:absolute;bottom:100%;left:50%;transform:translateX(-50%);background:var(--bg2);color:var(--ink);padding:6px 10px;border-radius:6px;font-size:0.8em;white-space:nowrap;opacity:0;pointer-events:none;transition:opacity 0.2s;border:1px solid var(--stroke)}
  .tooltip:hover:after{opacity:1}
  .pulse{animation:pulse 2s infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(115,225,255,0.4)}70%{box-shadow:0 0 0 10px rgba(115,225,255,0)}100%{box-shadow:0 0 0 0 rgba(115,225,255,0)}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">TAMAQUAH VAULT</div>
    <a class="pill" href="/">← Back to Landing</a>
  </header>

  <section class="hero">
    <h1>Mint Exclusive & Rare NFTs</h1>
    <p>Choose a collection, pick an ID (0–20), connect your wallet, and mint these unique digital artifacts.</p>
  </section>

  <div class="bar">
    <button id="connectBtn" class="btn ghost">Connect Wallet</button>
    <span id="addr" class="muted"></span>
    <div id="balanceDisplay" class="balance" style="display:none">
      <span id="balanceAmount">0</span>
      <span id="balanceCurrency" class="currency">BNB</span>
    </div>
  </div>
  <div class="bar" style="margin-top:-10px">
    <span id="connStatus" class="status muted" aria-live="polite"></span>
  </div>

  <section class="grid">
    <!-- Ancestral Mechs (BNB) -->
    <div class="card" id="mechsCard">
      <h2>Ancestral Mechs: Bloodline Codex</h2>
      <div class="muted contract">Contract: <code>0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989</code> • Pays in BNB</div>
      <div class="divider"></div>

      <div class="row">
        <label for="mechsTokenId">Token ID</label>
        <select id="mechsTokenId"></select>
        <label for="mechsQty">Qty</label>
        <input id="mechsQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="mechsImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="mechsName">—</h3>
          <div class="stat">Price/Token: <span id="mechsPrice" class="price">loading…</span></div>
          <div class="stat">Currency: <span id="mechsCurrency" class="price">loading…</span></div>
          <div class="stat">Supply: <span id="mechsSupply" class="price">—</span></div>
          <div class="stat">Your Balance: <span id="mechsBalance" class="price">—</span></div>
        </div>
      </div>

      <div class="row">
        <button id="mechsMint" class="btn">Mint Mech</button>
        <span id="mechsStatus" class="status muted"></span>
      </div>
    </div>

    <!-- Tribal Punk Cryptids (KLY) -->
    <div class="card" id="cryptidsCard">
      <h2>Tribal Punk Cryptids</h2>
      <div class="muted contract">Contract: <code>0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11</code> • Pays in KLY (auto‑approve)</div>
      <div class="divider"></div>

      <div class="row">
        <label for="cryptidTokenId">Token ID</label>
        <select id="cryptidTokenId"></select>
        <label for="cryptidQty">Qty</label>
        <input id="cryptidQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="cryptidImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="cryptidName">—</h3>
          <div class="stat">Price/Token: <span id="cryptidPrice" class="price">loading…</span></div>
          <div class="stat">Currency: <span id="cryptidCurrency" class="price">loading…</span></div>
          <div class="stat">Supply: <span id="cryptidSupply" class="price">—</span></div>
          <div class="stat">Your Balance: <span id="cryptidBalance" class="price">—</span></div>
        </div>
      </div>

      <div class="row">
        <button id="cryptidMint" class="btn">Mint Cryptid</button>
        <span id="cryptidStatus" class="status muted"></span>
      </div>
    </div>
  </section>

  <footer>They took the land. We took the future.</footer>
</div>

<script type="module">
  // ------------ CONFIG ------------
  const BSC_CHAIN = 56; // 97 for testnet
  const CONTRACT_MECHS = "0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989";  // Drop1155
  const CONTRACT_CRYPTIDS = "0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11"; // Drop1155
  const KLY_TOKEN = "0x2e4fEB2Fe668c8Ebe84f19e6c8fE8Cf8131B4E52";        // ERC-20 (on BSC)

  // Optional price pins
  const FORCED_MECHS_PRICE_BNB = "0.0063"; // keep stable at ~$5, or null
  const FORCED_CRYPTIDS_PRICE_KLY = null;  // read from contract claim condition

  // Read-only RPC for when wallet isn't connected
  const READ_RPC = "https://bsc-dataseed.binance.org/";

  // ------------ TOKEN LISTS ------------
  const T = (id, name, uri)=>({id, name, uri});

  const CRYPTIDS = [
    T(0,  "Wendigo.EXE",                 "ipfs://QmV2X7oUrG5i284sKQPHQJAbQV8HkL788mbZexuCA5oTvx/0"),
    T(1,  "Mask of Memory",              "ipfs://Qmbu7rbrAoG3cJTYEJGGJ6iZsPGpDQxhkJBsKt4QuBJj8N/0"),
    T(2,  "Wolf of Wounded Knee",        "ipfs://QmQm8nSAL56mGypS45f4AZ44xejVPWuktWidfZqAHdJtmk/0"),
    T(3,  "Coastal Sasquatch Punk",      "ipfs://QmV91qcvQmzwUEu4hin91iXqzVn7hn1F9gZ9bmfxnFTQje/0"),
    T(4,  "Anishinaabe Wendigo Protocol","ipfs://QmStEaLkFwNREJ3M4t42hNKvphwjHK1MxjA7CUdW15d6BE/0"),
    T(5,  "Desert Skinwalker Punk",      "ipfs://QmcW6m3B1ygPoMrsr4qVMaNC4uCL1s4EAq2LcdEsCj6iUS/0"),
    T(6,  "Métis Rougarou Rider",        "ipfs://Qmeg78oUMrM1fUGNMVzUNG2G5dEDuD8TLoB9Mh3j3X6zEF/0"),
    T(7,  "Cherokee Skinwalker Firewall","ipfs://QmWNsSbcy2iBmYjK2TCzELZTfzD1ezGj1WvktYiwnWnjjg/0"),
    T(8,  "Wabanaki Webworm",            "ipfs://QmdadZMbe1QMUW5i51smLxEDuWvRWKanLiiHdyb4zH2mbM/0"),
    T(9,  "Deer Woman DAO",              "ipfs://QmTmrUDMXuqnffe1duAEYdJGAKNeSdEsVvKe8dT8YKR4i7/0"),
    T(10, "The Cipherskin Codex",        "ipfs://QmPcWyNf93hwKXxBH5QpseeqmkE296arM1jkg4zcvi3bgC/0"),
    T(11, "Treaty.Exe",                  "ipfs://QmeGbsj4E3w9zaaEnQiSsDUrPUbbTWumn8BemBnsHNdFuR/0"),
    T(12, "Scroll of Unburied Seeds",    "ipfs://QmNXhjcuNvaYDW7PdDi7Erh1jbkhQb6ep15FAYcXVZUByE/0"),
    T(13, "The Disentrancer",            "ipfs://QmQP3hP9YyAkFZwKNkrw5apxEcZ7nAZecshsaE1sdpyGaz/0"),
    T(14, "Ledger Shaman",               "ipfs://QmNj8tHVjp4X1HNBFbm4nbw6mb2vzdMHrYDd8wQuE35qFw/0"),
    T(15, "The Ghost of Paper Genocide","ipfs://QmWbTfxSn4Mybnw3deUiFn3T8PVyyJkiCPZD9C91Sqz9Kk/0"),
    T(16, "Ironroot Codewalker",         "ipfs://QmWMhG22wfXFZufu7E2haVkqoc1XYf4bU8KXvVL6xUZZXW/0"),
    T(17, "Deer Woman 9.0",              "ipfs://QmRieQJ4gpkjMsJkaB99t2M5BX5sns6CWVJPa3HNwASCEB/0"),
    T(18, "Thunderbird 9G",              "ipfs://QmPnk3rYUeqeCevm7pjjfp31WrsUp8CzBP96TVRmmFky7h/0"),
    T(19, "Skinwalker 9S",               "ipfs://Qmbv4hEy6gW68XSUUW46nzYmptaxiWS1vFGig3457W1Wez/0"),
  ];

  const MECHS = [
    T(0, "Skybone Leviathan", "ipfs://QmXZaUkWziGrd2ooyXdQavJmPXCtWFjZrGL9239n4Nu7yU/0"),
    // add more mechs here as you mint them
  ];

  // ------------ ABIs ------------
  const DROP1155_ABI = [
    "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable",
    "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
    "function getClaimConditionById(uint256 _tokenId,uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata))",
    "function uri(uint256) view returns (string)"
  ];
  const ERC20_ABI = [
    "function approve(address spender,uint256 amount) returns (bool)",
    "function allowance(address owner,address spender) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function balanceOf(address) view returns (uint256)",
    "function symbol() view returns (string)"
  ];

  // ------------ DOM ------------
  const $ = (id)=>document.getElementById(id);
  const connectBtn = $("connectBtn"), addrEl = $("addr"), connStatus = $("connStatus");
  const balanceDisplay = $("balanceDisplay"), balanceAmount = $("balanceAmount"), balanceCurrency = $("balanceCurrency");

  const mechs = {
    sel:$("mechsTokenId"), qty:$("mechsQty"),
    img:$("mechsImg"), name:$("mechsName"),
    price:$("mechsPrice"), currency:$("mechsCurrency"), supply:$("mechsSupply"),
    balance:$("mechsBalance"), mint:$("mechsMint"), status:$("mechsStatus")
  };
  const crypt = {
    sel:$("cryptidTokenId"), qty:$("cryptidQty"),
    img:$("cryptidImg"), name:$("cryptidName"),
    price:$("cryptidPrice"), currency:$("cryptidCurrency"), supply:$("cryptidSupply"),
    balance:$("cryptidBalance"), mint:$("cryptidMint"), status:$("cryptidStatus")
  };

  // Fill dropdowns
  function fillOptions(sel, list){
    sel.innerHTML = "";
    list.forEach(x=>{
      const o=document.createElement("option");
      o.value = x.id; o.textContent = `${x.id} – ${x.name}`;
      sel.appendChild(o);
    });
  }
  fillOptions(mechs.sel, MECHS);
  fillOptions(crypt.sel, CRYPTIDS);

  // ------------ Web3 ------------
  let web3Modal, provider, ethersProvider, signer, userAddr;

  function initWeb3Modal(){
    web3Modal = new window.Web3Modal.default({ 
      cacheProvider: true,
      theme: "dark",
      providerOptions: {} 
    });
  }

  function readProvider(){
    return ethersProvider ?? new ethers.providers.JsonRpcProvider(READ_RPC);
  }

  function idToHex(n){ return n.toString(16).padStart(64, "0"); }

  function ipfsHttp(url, gatewayIndex=0){
    if (!url) return "";
    if (!url.startsWith("ipfs://")) return url;
    const cid = url.slice(7);
    const gateways = [
      "https://ipfs.io/ipfs/",
      "https://cloudflare-ipfs.com/ipfs/",
      "https://gateway.pinata.cloud/ipfs/"
    ];
    const path = cid;
    return gateways[Math.min(gatewayIndex, gateways.length-1)] + path;
  }

  async function fetchJsonWithFallback(ipfsUrl){
    let lastErr;
    for (let i=0;i<3;i++){
      const http = ipfsHttp(ipfsUrl, i);
      try{
        const r = await fetch(http);
        if (!r.ok) throw new Error(`Fetch failed ${r.status}`);
        return await r.json();
      }catch(e){ lastErr = e; }
    }
    throw lastErr ?? new Error("Fetch failed");
  }

    async function connect(){
      try {
        connectBtn.disabled = true;
        setStatus("warning", "Connecting…");

        const instance = await web3Modal.connect();
        provider = instance;
        ethersProvider = new ethers.providers.Web3Provider(provider, "any");

        await provider.request?.({ method: "eth_requestAccounts" });

        await ensureBsc();

        // events
        provider.on?.("chainChanged", ()=>window.location.reload());
        provider.on?.("accountsChanged", acc=>{
          if (!acc?.length) return handleDisconnect();
          userAddr = acc[0]; addrEl.textContent = shorten(userAddr); updateUi();
        });
        provider.on?.("disconnect", handleDisconnect);

        signer = ethersProvider.getSigner();
        userAddr = await signer.getAddress();

        addrEl.textContent = shorten(userAddr);
        setStatus("success", "Connected");
        connectBtn.textContent = "Connected";

        await updateUi();
      } catch (e){
        console.error(e);
        setStatus("error", `Connection failed: ${e?.message || e}`);
        connectBtn.textContent = "Connect Wallet";
      } finally {
        connectBtn.disabled = false;
      }
    }

    async function updateUi(){
      try{
        const net = await ethersProvider.getNetwork();
        netEl.textContent = `${net.chainId} (${net.name || "unknown"})`;
        const bal = await ethersProvider.getBalance(userAddr);
        balEl.textContent = parseFloat(ethers.utils.formatEther(bal)).toFixed(4);
      }catch(e){
        console.error(e);
      }
    }

    function handleDisconnect(){
      web3Modal?.clearCachedProvider?.();
      provider = signer = ethersProvider = null;
      userAddr = null;
      addrEl.textContent = "—";
      netEl.textContent  = "—";
      balEl.textContent  = "—";
      connectBtn.textContent = "Connect Wallet";
      setStatus("warning", "Wallet disconnected.");
    }

    window.addEventListener("load", ()=>{
      initWeb3Modal();
      connectBtn.addEventListener("click", connect);
      setStatus("", "");
    });
  // ------------ Helpers ------------
  async function load1155Meta(contractAddr, tokenId) {
    const c = new ethers.Contract(contractAddr, DROP1155_ABI, readProvider());
    const base = await c.uri(tokenId);
    const url = base.includes("{id}") ? base.replace("{id}", idToHex(tokenId)) : base;
    return fetchJsonWithFallback(ipfsToHttp(url));
  }

  function ipfsToHttp(u){ return ipfsHttp(u); }

  async function fetchJson(url){
    const r = await fetch(url); 
    if(!r.ok) throw new Error("Failed to fetch "+url);
    return r.json();
  }

  async function readClaim(contractAddr, tokenId){
    const c = new ethers.Contract(contractAddr, DROP1155_ABI, readProvider());
    const condId = await c.getActiveClaimConditionId(tokenId);
    const cond = await c.getClaimConditionById(tokenId, condId);
    return {
      // indexes per ABI
      max: cond[1],
      claimed: cond[2],
      quantityLimitPerWallet: cond[3],
      pricePerToken: cond[5],
      currency: cond[6],
    };
  }

  function fmtEth(wei){ return ethers.utils.formatEther(wei); }
  function toWei(s){ return ethers.utils.parseEther(s); }

  function setStatus(element, type, message) {
    element.textContent = message;
    element.className = "status " + (type||"");
  }

  async function updateBalances() {
    if (!userAddr || !ethersProvider) return;
    try {
      const bnbBalance = await ethersProvider.getBalance(userAddr);
      balanceAmount.textContent = parseFloat(fmtEth(bnbBalance)).toFixed(4);
      balanceCurrency.textContent = "BNB";
      mechs.balance.textContent = `${parseFloat(fmtEth(bnbBalance)).toFixed(4)} BNB`;

      // KLY ERC-20
      const kly = new ethers.Contract(KLY_TOKEN, ERC20_ABI, readProvider());
      const [klyBal, klyDec, klySym] = await Promise.all([
        kly.balanceOf(userAddr),
        kly.decimals(),
        kly.symbol()
      ]);
      crypt.balance.textContent = `${parseFloat(ethers.utils.formatUnits(klyBal, klyDec)).toFixed(2)} ${klySym}`;
    } catch (e) {
      console.error("Error updating balances:", e);
    }
  }

  // cache for ERC20 metadata
  const erc20MetaCache = new Map();
  async function getErc20Meta(addr){
    if (erc20MetaCache.has(addr)) return erc20MetaCache.get(addr);
    const k = new ethers.Contract(addr, ERC20_ABI, readProvider());
    const [dec, sym] = await Promise.all([k.decimals(), k.symbol()]);
    const meta = {decimals: dec, symbol: sym};
    erc20MetaCache.set(addr, meta);
    return meta;
  }

  // ------------ Render Previews ------------
  async function renderMech(){
    const id = Number(mechs.sel.value);
    const entry = MECHS.find(x=>x.id===id);
    mechs.name.textContent = entry?.name || `Token #${id}`;
    mechs.img.src = "";
    mechs.img.alt = "Preview";

    // loading UI
    [mechs.img, mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.add("loading"));

    // image
    try {
      const meta = entry?.uri ? await fetchJsonWithFallback(ipfsToHttp(entry.uri)) : await load1155Meta(CONTRACT_MECHS, id);
      const imgCandidates = meta.image || meta.image_url || meta.imageUri || "";
      // try 3 gateways if image fails
      let gatewayTry = 0;
      function setNext(){
        mechs.img.src = ipfsHttp(imgCandidates, gatewayTry++);
      }
      mechs.img.onerror = ()=>{ if (gatewayTry<3) setNext(); };
      setNext();
    } catch(e) { 
      console.error("Error loading mech preview:", e);
      mechs.img.alt = "Preview unavailable"; 
    } finally {
      mechs.img.classList.remove("loading");
    }

    // price & supply
    try {
      const claim = await readClaim(CONTRACT_MECHS, id);
      const isNative = (claim.currency === ethers.constants.AddressZero);
      const onChainPrice = claim.pricePerToken;
      const price = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : onChainPrice;

      mechs.price.textContent = `${fmtEth(price)} BNB`;
      mechs.currency.textContent = isNative ? "BNB" : "ERC20";
      mechs.supply.textContent = `${claim.claimed.toString()} / ${claim.max.toString()}`;

      // clamp quantity to wallet limit if any (>0)
      const maxPerWallet = ethers.BigNumber.from(claim.quantityLimitPerWallet || 0);
      const currentQty = Math.max(1, Number(mechs.qty.value) || 1);
      const clamped = maxPerWallet.gt(0) ? Math.min(currentQty, maxPerWallet.toNumber()) : currentQty;
      if (clamped !== currentQty){
        mechs.qty.value = clamped;
        setStatus(mechs.status, "warning", `Clamped to wallet limit: ${clamped}`);
      } else {
        setStatus(mechs.status, "", "");
      }

      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      const total = price.mul(qty);
      mechs.mint.textContent = `Mint for ${parseFloat(fmtEth(total)).toFixed(4)} BNB (est.)`;
    } catch(e) { 
      console.error("Error loading mech price:", e);
      mechs.price.textContent="—"; 
      mechs.currency.textContent="—"; 
      mechs.supply.textContent="—";
      mechs.mint.textContent = "Mint Mech";
    } finally {
      [mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.remove("loading"));
    }
  }

  async function renderCryptid(){
    const id = Number(crypt.sel.value);
    const entry = CRYPTIDS.find(x=>x.id===id);
    crypt.name.textContent = entry?.name || `Token #${id}`;
    crypt.img.src = "";
    crypt.img.alt = "Preview";

    [crypt.img, crypt.price, crypt.currency, crypt.supply].forEach(el=>el.classList.add("loading"));

    try {
      const meta = entry?.uri ? await fetchJsonWithFallback(ipfsToHttp(entry.uri)) : await load1155Meta(CONTRACT_CRYPTIDS, id);
      const imgCandidates = meta.image || meta.image_url || meta.imageUri || "";
      let gatewayTry = 0;
      function setNext(){
        crypt.img.src = ipfsHttp(imgCandidates, gatewayTry++);
      }
      crypt.img.onerror = ()=>{ if (gatewayTry<3) setNext(); };
      setNext();
    } catch(e) { 
      console.error("Error loading cryptid preview:", e);
      crypt.img.alt = "Preview unavailable"; 
    } finally {
      crypt.img.classList.remove("loading");
    }

    try {
      const claim = await readClaim(CONTRACT_CRYPTIDS, id);
      const erc20Addr = claim.currency;
      const meta = await getErc20Meta(erc20Addr || KLY_TOKEN); // fallback to known KLY
      const price = FORCED_CRYPTIDS_PRICE_KLY
        ? ethers.utils.parseUnits(FORCED_CRYPTIDS_PRICE_KLY, meta.decimals)
        : claim.pricePerToken;

      crypt.price.textContent = `${ethers.utils.formatUnits(price, meta.decimals)} ${meta.symbol}`;
      crypt.currency.textContent = meta.symbol;
      crypt.supply.textContent = `${claim.claimed.toString()} / ${claim.max.toString()}`;

      const maxPerWallet = ethers.BigNumber.from(claim.quantityLimitPerWallet || 0);
      const currentQty = Math.max(1, Number(crypt.qty.value) || 1);
      const clamped = maxPerWallet.gt(0) ? Math.min(currentQty, maxPerWallet.toNumber()) : currentQty;
      if (clamped !== currentQty){
        crypt.qty.value = clamped;
        setStatus(crypt.status, "warning", `Clamped to wallet limit: ${clamped}`);
      } else {
        setStatus(crypt.status, "", "");
      }

      const qty = Math.max(1, Number(crypt.qty.value) || 1);
      const total = price.mul(qty);
      crypt.mint.textContent = `Mint for ${parseFloat(ethers.utils.formatUnits(total, meta.decimals)).toFixed(2)} ${meta.symbol} (est.)`;
    } catch(e) { 
      console.error("Error loading cryptid price:", e);
      crypt.price.textContent="—"; 
      crypt.currency.textContent="—"; 
      crypt.supply.textContent="—";
      crypt.mint.textContent = "Mint Cryptid";
    } finally {
      [crypt.price, crypt.currency, crypt.supply].forEach(el=>el.classList.remove("loading"));
    }
  }

  async function refreshAll(){
    try {
      await Promise.all([renderMech(), renderCryptid()]);
      if (userAddr) await updateBalances();
    } catch (e) {
      console.error("Error refreshing data:", e);
    }
  }

  // Events
  mechs.sel.addEventListener("change", renderMech);
  crypt.sel.addEventListener("change", renderCryptid);
  mechs.qty.addEventListener("change", renderMech);
  crypt.qty.addEventListener("change", renderCryptid);

  // ------------ Mint ------------
  function makeAllowlistProof(pricePer, currency){
    // default open claim (no proof)
    return {
      proof: [],
      quantityLimitPerWallet: 0,
      pricePerToken: pricePer,
      currency
    };
  }

  async function mintMech(){
    try {
      if (!signer) { await connect(); if (!signer) return; }

      mechs.mint.disabled = true; 
      mechs.mint.classList.add("loading");
      setStatus(mechs.status, "warning", "Preparing transaction…");

      const tokenId = Number(mechs.sel.value);
      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      const drop = new ethers.Contract(CONTRACT_MECHS, DROP1155_ABI, signer);

      const condId = await drop.getActiveClaimConditionId(tokenId);
      const cond = await drop.getClaimConditionById(tokenId, condId);
      const pricePer = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : cond.pricePerToken;
      const totalValue = pricePer.mul(qty);

      // balance check
      const userBalance = await ethersProvider.getBalance(userAddr);
      if (userBalance.lt(totalValue)) {
        throw new Error(`Insufficient BNB balance. Needed: ${fmtEth(totalValue)}, have: ${fmtEth(userBalance)}`);
      }

      // final button price refresh
      mechs.mint.textContent = `Mint for ${parseFloat(fmtEth(totalValue)).toFixed(4)} BNB`;

      const allowlist = makeAllowlistProof(pricePer, ethers.constants.AddressZero);
      const tx = await drop.claim(
        userAddr,
        tokenId,
        qty,
        ethers.constants.AddressZero,
        pricePer,
        allowlist,
        "0x",
        { value: totalValue }
      );

      setStatus(mechs.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(mechs.status, "success", `Minted! Tx: ${rec.transactionHash.slice(0,10)}…`);
      await refreshAll();
    } catch(e){
      console.error(e);
      const msg = (e && (e.data?.message || e.error?.message || e.message)) || "Transaction failed";
      setStatus(mechs.status, "error", msg);
    } finally {
      mechs.mint.disabled = false;
      mechs.mint.classList.remove("loading");
    }
  }

  async function mintCryptid(){
    try {
      if (!signer) { await connect(); if (!signer) return; }

      crypt.mint.disabled = true; 
      crypt.mint.classList.add("loading");
      setStatus(crypt.status, "warning", "Preparing transaction…");

      const tokenId = Number(crypt.sel.value);
      const qty = Math.max(1, Number(crypt.qty.value) || 1);
      const drop = new ethers.Contract(CONTRACT_CRYPTIDS, DROP1155_ABI, signer);

      const condId = await drop.getActiveClaimConditionId(tokenId);
      const cond = await drop.getClaimConditionById(tokenId, condId);

      // currency + price (ERC20)
      const erc20Addr = cond.currency || KLY_TOKEN;
      const erc20 = new ethers.Contract(erc20Addr, ERC20_ABI, signer);
      const meta = await getErc20Meta(erc20Addr);
      const pricePer = FORCED_CRYPTIDS_PRICE_KLY
        ? ethers.utils.parseUnits(FORCED_CRYPTIDS_PRICE_KLY, meta.decimals)
        : cond.pricePerToken;
      const total = pricePer.mul(qty);

      // balance/allowance checks
      const [bal, allowance] = await Promise.all([
        erc20.balanceOf(userAddr),
        erc20.allowance(userAddr, CONTRACT_CRYPTIDS)
      ]);
      if (bal.lt(total)){
        throw new Error(`Insufficient ${meta.symbol}. Need ${ethers.utils.formatUnits(total, meta.decimals)} ${meta.symbol}.`);
      }
      if (allowance.lt(total)){
        setStatus(crypt.status, "warning", `Approving ${meta.symbol}…`);
        const txA = await erc20.approve(CONTRACT_CRYPTIDS, total);
        await txA.wait();
      }

      // final button text
      crypt.mint.textContent = `Minting…`;

      const allowlist = makeAllowlistProof(pricePer, erc20Addr);
      const tx = await drop.claim(
        userAddr,
        tokenId,
        qty,
        erc20Addr,
        pricePer,
        allowlist,
        "0x"
      );

      setStatus(crypt.status, "warning", "Broadcasted. Waiting for confirmation…");
      const rec = await tx.wait();
      setStatus(crypt.status, "success", `Minted! Tx: ${rec.transactionHash.slice(0,10)}…`);
      await refreshAll();
    } catch(e){
      console.error(e);
      const msg = (e && (e.data?.message || e.error?.message || e.message)) || "Transaction failed";
      setStatus(crypt.status, "error", msg);
    } finally {
      crypt.mint.disabled = false;
      crypt.mint.classList.remove("loading");
    }
  }

  mechs.mint.addEventListener("click", mintMech);
  crypt.mint.addEventListener("click", mintCryptid);

  // ------------ Boot ------------
  initWeb3Modal();
  connectBtn.addEventListener("click", connect);
  refreshAll();
</script>
</body>
</html>
