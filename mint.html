<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tamaquah Vault — Mint</title>

<!-- Ethers v6 (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>

<style>
  :root { --bg:#0A1A24; --bg2:#051018; --ink:#EAF7FF; --sub:#9CCBE3; --accent:#73E1FF; --gold:#e2c675;
          --metamask:#f6851b; --card:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12);
          --success:#4ade80; --error:#f87171; --warning:#fbbf24; }
  *{box-sizing:border-box} html,body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);
  font-family:Inter,system-ui,Arial,sans-serif;min-height:100vh}
  .wrap{max-width:1100px;margin:0 auto;padding:2rem}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem}
  .brand{font-weight:800;letter-spacing:.08em;font-size:1.35rem;color:var(--accent)}
  .hero{margin:1rem 0 1.5rem;text-align:center}
  .hero h1{margin:.25rem 0 .5rem;font-size:clamp(1.6rem,4.5vw,2.6rem);background:linear-gradient(90deg,var(--accent),var(--gold));
  -webkit-background-clip:text;-webkit-text-fill-color:transparent}
  .hero p{color:var(--sub)}
  .wallet-section{display:flex;flex-direction:column;align-items:center;gap:.75rem}
  .btn{background:linear-gradient(90deg,var(--metamask),#f8a34d);color:#fff;border:none;border-radius:12px;padding:.9rem 1.2rem;
  font-weight:700;cursor:pointer;display:flex;align-items:center;gap:.5rem}
  .btn.loading{opacity:.7;cursor:progress}
  .wallet-info{display:flex;gap:.75rem;align-items:center;background:rgba(0,0,0,.2);padding:.5rem 1rem;border-radius:999px}
  .wallet-address{font-family:ui-monospace,monospace}
  .network-indicator{padding:.25rem .65rem;border-radius:999px;font-size:.85rem}
  .network-indicator.valid{background:rgba(74,222,128,.12);color:var(--success)}
  .network-indicator.invalid{background:rgba(248,113,113,.12);color:var(--error)}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(340px,1fr));gap:1.25rem;margin-top:1.25rem}
  .card{background:var(--card);border:1px solid var(--stroke);border-radius:14px;padding:1.1rem}
  .card h2{margin:0 0 .6rem;font-size:1.2rem}
  .contract-address{display:block;color:var(--sub);font-size:.85rem;word-break:break-all;margin-bottom:.6rem}
  .form-group{display:flex;flex-wrap:wrap;gap:.6rem;align-items:center;margin:.6rem 0}
  select,input[type=number]{background:#0c1d27;color:var(--ink);border:1px solid var(--stroke);border-radius:10px;padding:.6rem .8rem}
  .preview{display:flex;gap:1rem;margin:1rem 0}
  .preview img{width:170px;height:170px;object-fit:cover;border-radius:10px;border:1px solid var(--stroke);
  background:linear-gradient(45deg,#0c1d27,#0a2738)}
  .meta{flex:1}
  .nft-name{margin:.15rem 0 .5rem;font-size:1.1rem}
  .stat{display:flex;justify-content:space-between;margin:.35rem 0;font-size:.95rem}
  .stat-label{color:var(--sub)}
  .mint-btn{background:linear-gradient(90deg,var(--accent),#a9ffcb);color:#001018;border:none;border-radius:12px;padding:.9rem 1rem;
  font-weight:800;cursor:pointer;width:100%}
  .status{min-height:22px;margin-top:.6rem;font-size:.92rem;text-align:center}
  .status.success{color:var(--success)} .status.error{color:var(--error)} .status.warning{color:var(--warning)}
  .loading{position:relative;color:transparent!important}
  .loading:after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:14px;height:14px;border:2px solid rgba(255,255,255,.25);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:translate(-50%,-50%) rotate(360deg)}}
  footer{margin:2rem 0 0;text-align:center;color:var(--sub);font-size:.9rem}
</style>
</head>
<body>
<div class="wrap">
  <header><div class="brand">TAMAQUAH VAULT</div></header>

  <section class="hero">
    <h1>Mint Exclusive & Rare NFTs</h1>
    <p>Connect your wallet, pick a Mech, and mint on BNB Chain.</p>
  </section>

  <div class="wallet-section">
    <button id="connectBtn" class="btn">Connect MetaMask</button>
    <div id="walletInfo" class="wallet-info" style="display:none">
      <span id="walletAddress" class="wallet-address">—</span>
      <span class="network-indicator" id="netBadge"><span id="networkName">—</span></span>
      <span>Balance: <b id="balanceAmount">0</b> <span id="balanceCurrency">BNB</span></span>
    </div>
    <div id="connStatus" class="status"></div>
  </div>

  <section class="grid">
    <!-- MECHS -->
    <div class="card" id="mechsCard">
      <h2>Ancestral Mechs: Bloodline Codex</h2>
      <span class="contract-address">Drop1155: 0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989</span>

      <div class="form-group">
        <label for="mechsTokenId">Token</label>
        <select id="mechsTokenId"></select>
        <label for="mechsQty">Qty</label>
        <input id="mechsQty" type="number" min="1" max="10" value="1"/>
      </div>

      <div class="preview">
        <img id="mechsImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="mechsName" class="nft-name">—</h3>
          <div class="stat"><span class="stat-label">Price/Token</span><span id="mechsPrice">—</span></div>
          <div class="stat"><span class="stat-label">Currency</span><span id="mechsCurrency">—</span></div>
          <div class="stat"><span class="stat-label">Supply</span><span id="mechsSupply">—</span></div>
          <div class="stat"><span class="stat-label">Your BNB</span><span id="mechsBalance">—</span></div>
        </div>
      </div>

      <button id="mechsMint" class="mint-btn">Mint Mech</button>
      <div id="mechsStatus" class="status"></div>
    </div>

    <!-- CRYPTIDS (preview only) -->
    <div class="card" id="cryptidsCard">
      <h2>Tribal Punk Cryptids</h2>
      <span class="contract-address">ERC-721 (preview): 0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11</span>
      <div class="form-group">
        <label for="cryptidTokenId">Token</label>
        <select id="cryptidTokenId"></select>
        <label for="cryptidQty">Qty</label>
        <input id="cryptidQty" type="number" min="1" value="1" disabled/>
      </div>
      <div class="preview">
        <img id="cryptidImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="cryptidName" class="nft-name">—</h3>
          <div class="stat"><span class="stat-label">Price/Token</span><span id="cryptidPrice">—</span></div>
          <div class="stat"><span class="stat-label">Currency</span><span id="cryptidCurrency">—</span></div>
          <div class="stat"><span class="stat-label">Supply</span><span id="cryptidSupply">—</span></div>
          <div class="stat"><span class="stat-label">Your Balance</span><span id="cryptidBalance">—</span></div>
        </div>
      </div>
      <button id="cryptidMint" class="mint-btn" disabled>Mint Cryptid (requires signature)</button>
      <div id="cryptidStatus" class="status warning">Signature mint not enabled here.</div>
    </div>
  </section>

  <footer>They took the land. We took the future.</footer>
</div>

<script type="module">
/* ================== CONFIG ================== */
const BSC_CHAIN_ID = 56;
const READ_RPC = "https://bsc-dataseed.binance.org/";
const CONTRACT_MECHS    = "0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989"; // Drop1155
const CONTRACT_CRYPTIDS = "0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11"; // preview only

// optional UI override for native price (null => on-chain)
const FORCED_MECHS_PRICE_BNB = null;

/* ================== TOKEN LISTS ================== */
const MECHS = [
  { id:0, name:"Skybone Leviathan",                           uri:"ipfs://QmXZaUkWziGrd2ooyXdQavJmPXCtWFjZrGL9239n4Nu7yU/0" },
  { id:1, name:"Obsidian Jaguar",                             uri:"ipfs://Qmc7FAsop9nLMNfof4aYumKfSJ71sTWHhiAroKL5mA1Z4h/1" },
  { id:2, name:"Red Clay Colossus",                           uri:"ipfs://QmdKMicaGDbmAGkaJiXNgHU6TJWrq8AB1purSBd4fyJmB7/2" },
  { id:3, name:"SERPENT COIL MK-VII — River & Data Guardian", uri:"ipfs://Qmc1U4xsf4Yaw8D7B86v5TcDpWSFaftxX98Sh28TtU38x1/3" },
  { id:4, name:"Void Sifu",                                   uri:"ipfs://QmXtzw2ASNnzhp3EyJXRGWQJ62RDy2b6MdCkH4dDiMY17p/4" },
];
const CRYPTIDS = [
  { id:0,  name:"Wendigo.EXE",                  uri:"ipfs://QmV2X7oUrG5i284sKQPHQJAbQV8HkL788mbZexuCA5oTvx/0" },
  { id:1,  name:"Mask of Memory",               uri:"ipfs://Qmbu7rbrAoG3cJTYEJGGJ6iZsPGpDQxhkJBsKt4QuBJj8N/0" },
  { id:2,  name:"Wolf of Wounded Knee",         uri:"ipfs://QmQm8nSAL56mGypS45f4AZ44xejVPWuktWidfZqAHdJtmk/0" },
  { id:3,  name:"Coastal Sasquatch Punk",       uri:"ipfs://QmV91qcvQmzwUEu4hin91iXqzVn7hn1F9gZ9bmfxnFTQje/0" },
  { id:4,  name:"Anishinaabe Wendigo Protocol", uri:"ipfs://QmStEaLkFwNREJ3M4t42hNKvphwjHK1MxjA7CUdW15d6BE/0" },
  { id:5,  name:"Desert Skinwalker Punk",       uri:"ipfs://QmcW6m3B1ygPoMrsr4qVMaNC4uCL1s4EAq2C..." },
];

/* ================== ABIs ================== */
const MECHS_READ_ABI = [
  "function uri(uint256) view returns (string)",
  "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
  "function getClaimConditionById(uint256 _tokenId,uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata) condition)"
];
const MECHS_CLAIM_ABI = [
  "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable"
];
const MECHS_ERROR_ABI = [
  "error BatchMintInvalidBatchId(uint256 index)",
  "error BatchMintInvalidTokenId(uint256 tokenId)",
  "error DropClaimExceedLimit(uint256 expected,uint256 actual)",
  "error DropClaimExceedMaxSupply(uint256 expected,uint256 actual)",
  "error DropClaimInvalidTokenPrice(address expectedCurrency,uint256 expectedPricePerToken,address actualCurrency,uint256 actualExpectedPricePerToken)",
  "error DropClaimNotStarted(uint256 expected,uint256 actual)",
  "error DropNoActiveCondition()",
  "error DropUnauthorized()",
  "error CurrencyTransferLibFailedNativeTransfer(address recipient,uint256 value)"
];
const ERC20_READ_ABI = [
  "function allowance(address owner,address spender) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint256)",
  "function symbol() view returns (string)"
];
const ERC20_APPROVE_BOOL_ABI = [ "function approve(address spender,uint256 amount) returns (bool)" ];
const ERC20_APPROVE_NO_RET_IFACE = new ethers.Interface([ "function approve(address spender,uint256 amount)" ]);

/* ================== DOM ================== */
const connectBtn = document.getElementById('connectBtn');
const walletInfo = document.getElementById('walletInfo');
const walletAddress = document.getElementById('walletAddress');
const networkName = document.getElementById('networkName');
const netBadge = document.getElementById('netBadge');
const balanceAmount = document.getElementById('balanceAmount');
const balanceCurrency = document.getElementById('balanceCurrency');
const connStatus = document.getElementById('connStatus');

const mechs = {
  sel: document.getElementById("mechsTokenId"), qty: document.getElementById("mechsQty"),
  img: document.getElementById("mechsImg"), name: document.getElementById("mechsName"),
  price: document.getElementById("mechsPrice"), currency: document.getElementById("mechsCurrency"),
  supply: document.getElementById("mechsSupply"), balance: document.getElementById("mechsBalance"),
  mint: document.getElementById("mechsMint"), status: document.getElementById("mechsStatus")
};
const crypt = {
  sel: document.getElementById("cryptidTokenId"), qty: document.getElementById("cryptidQty"),
  img: document.getElementById("cryptidImg"), name: document.getElementById("cryptidName"),
  price: document.getElementById("cryptidPrice"), currency: document.getElementById("cryptidCurrency"),
  supply: document.getElementById("cryptidSupply"), balance: document.getElementById("cryptidBalance"),
  mint: document.getElementById("cryptidMint"), status: document.getElementById("cryptidStatus")
};

/* ================== Providers / State ================== */
const readProvider = new ethers.JsonRpcProvider(READ_RPC);
let browserProvider = null, signer = null, userAddr = null;

/* ================== Utils ================== */
const ZERO = ethers.ZeroAddress;
const shorten = a => a ? `${a.slice(0,6)}…${a.slice(-4)}` : "—";
const idToHex = n => Number(n).toString(16).padStart(64,"0");
const fmtEth = v => ethers.formatEther(v);
const toWei  = s => ethers.parseEther(s);
const trim = (s,dec=6)=>{ const [i,f='']=String(s).split('.'); return f?`${i}.${f.slice(0,dec)}`:`${i}.0`.slice(0,i.length+1+dec); };
const isZeroAddress = a => !!a && a.toLowerCase()===ZERO.toLowerCase();

function ipfsHttp(url, i=0){
  if (!url) return "";
  if (!url.startsWith("ipfs://")) return url;
  const p = url.slice(7);
  const gws = ["https://ipfs.io/ipfs/","https://cloudflare-ipfs.com/ipfs/","https://gateway.pinata.cloud/ipfs/"];
  return gws[Math.min(i,gws.length-1)] + p;
}
async function fetchJsonWithFallback(ipfsUrl){
  let lastErr;
  for (let i=0;i<3;i++){
    try{ const r=await fetch(ipfsHttp(ipfsUrl,i)); if(!r.ok) throw new Error(`HTTP ${r.status}`); return await r.json(); }
    catch(e){ lastErr=e; }
  }
  throw lastErr || new Error("IPFS fetch failed");
}
function setStatus(el, type, msg){ el.textContent = msg; el.className = "status " + (type||""); }

const FULL_MECHS_IFACE = new ethers.Interface([ ...MECHS_CLAIM_ABI, ...MECHS_ERROR_ABI ]);
function prettyRevert(e){
  const data = e?.data || e?.error?.data || e?.info?.error?.data || e?.error?.error?.data;
  if (typeof data==="string" && data.startsWith("0x")) {
    try {
      const dec = FULL_MECHS_IFACE.decodeErrorResult(data);
      const args = dec.args?.length ? " " + JSON.stringify(dec.args.map(a => typeof a==="bigint"?a.toString():a)) : "";
      return `${dec.name}${args}`;
    } catch {}
  }
  return e?.error?.message || e?.info?.error?.message || e?.data?.message || e?.reason || e?.shortMessage || e?.message || 'Unknown error';
}

/* ================== Chain helpers ================== */
async function load1155Meta(contractAddr, tokenId){
  try{
    const c = new ethers.Contract(contractAddr, MECHS_READ_ABI, readProvider);
    const base = await c.uri(tokenId);
    const url = base.includes("{id}") ? base.replace("{id}", idToHex(tokenId)) : base;
    return await fetchJsonWithFallback(url);
  }catch{ return {}; }
}
async function readClaim(contractAddr, tokenId){
  const c = new ethers.Contract(contractAddr, MECHS_READ_ABI, readProvider);
  const condId = await c.getActiveClaimConditionId(tokenId);
  const cond = await c.getClaimConditionById(tokenId, condId);
  return {
    max: cond.maxClaimableSupply,
    claimed: cond.supplyClaimed,
    quantityLimitPerWallet: cond.quantityLimitPerWallet,
    pricePerToken: cond.pricePerToken,
    currency: cond.currency
  };
}

// simulate via eth_call
async function simulateClaim({ to, value, args }){
  const data = FULL_MECHS_IFACE.encodeFunctionData("claim", args);
  try{ await signer.call({ to, data, value }); }
  catch(e){ throw new Error(prettyRevert(e)); }
}
async function sendRawClaim({ to, value, args }){
  const data = FULL_MECHS_IFACE.encodeFunctionData("claim", args);
  let gasLimit;
  try{ const est = await signer.estimateGas({ to, data, value }); gasLimit = (est * 120n)/100n; }catch{}
  const tx = await signer.sendTransaction({ to, data, value, ...(gasLimit?{gasLimit}:{}) });
  return await tx.wait();
}

/* ================== ERC20 approve helper ================== */
async function safeApprove(tokenAddr, spender, amount){
  try {
    const erc20Bool = new ethers.Contract(tokenAddr, ERC20_APPROVE_BOOL_ABI, signer);
    const tx = await erc20Bool.approve(spender, amount);
    return await tx.wait();
  } catch (e) {
    const msg = prettyRevert(e);
    if (/decode result|could not decode/i.test(msg)) {
      const data = ERC20_APPROVE_NO_RET_IFACE.encodeFunctionData("approve", [spender, amount]);
      let gasLimit; try{ const est=await signer.estimateGas({to:tokenAddr,data}); gasLimit=(est*120n)/100n; }catch{}
      const tx = await signer.sendTransaction({ to: tokenAddr, data, ...(gasLimit?{gasLimit}:{}) });
      return await tx.wait();
    }
    throw e;
  }
}

/* ================== Wallet ================== */
async function connectWallet(){
  try{
    if (!window.ethereum) throw new Error('MetaMask not detected');
    connectBtn.disabled = true; connectBtn.classList.add('loading');
    setStatus(connStatus,'warning','Connecting…');

    browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
    await browserProvider.send('eth_requestAccounts',[]);
    let net = await browserProvider.getNetwork();
    if (Number(net.chainId)!==BSC_CHAIN_ID){
      try{
        await browserProvider.send('wallet_switchEthereumChain',[{chainId:'0x'+BSC_CHAIN_ID.toString(16)}]);
      }catch(err){
        if (err?.code===4902){
          await browserProvider.send('wallet_addEthereumChain',[{
            chainId:'0x'+BSC_CHAIN_ID.toString(16),
            chainName:'BNB Smart Chain',
            nativeCurrency:{ name:'BNB', symbol:'BNB', decimals:18 },
            rpcUrls:['https://bsc-dataseed1.bnbchain.org','https://bsc-dataseed2.bnbchain.org','https://bsc-dataseed.binance.org'],
            blockExplorerUrls:['https://bscscan.com/']
          }]);
        } else throw err;
      }
      net = await browserProvider.getNetwork();
    }
    signer = await browserProvider.getSigner();
    userAddr = await signer.getAddress();

    walletInfo.style.display='flex';
    walletAddress.textContent = shorten(userAddr);
    networkName.textContent = (Number(net.chainId)===56?'BSC':`Chain ${net.chainId}`);
    netBadge.className = 'network-indicator ' + (Number(net.chainId)===56?'valid':'invalid');

    const bal = await browserProvider.getBalance(userAddr);
    balanceAmount.textContent = trim(fmtEth(bal),4);
    balanceCurrency.textContent = 'BNB';
    mechs.balance.textContent = `${trim(fmtEth(bal),4)} BNB`;

    window.ethereum.on?.('accountsChanged', handleAccountsChanged);
    window.ethereum.on?.('chainChanged', handleChainChanged);

    setStatus(connStatus,'success','Connected');
  } catch(e){
    setStatus(connStatus,'error', prettyRevert(e));
  } finally {
    connectBtn.disabled=false; connectBtn.classList.remove('loading');
  }
}
function handleAccountsChanged(acc){
  if (!acc?.length) { disconnectWallet(); return; }
  userAddr = acc[0];
  walletAddress.textContent = shorten(userAddr);
  updateBalance(); renderMech();
}
function handleChainChanged(){
  if (window.ethereum) browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
  updateNetworkIndicator(); updateBalance(); renderMech();
}
function disconnectWallet(){
  try{
    window.ethereum?.removeListener?.('accountsChanged', handleAccountsChanged);
    window.ethereum?.removeListener?.('chainChanged', handleChainChanged);
  }catch{}
  browserProvider=null; signer=null; userAddr=null;
  walletInfo.style.display='none'; setStatus(connStatus,'','');
}
async function updateNetworkIndicator(){
  if (!browserProvider) return;
  const net = await browserProvider.getNetwork();
  networkName.textContent = (Number(net.chainId)===56?'BSC':`Chain ${net.chainId}`);
  netBadge.className = 'network-indicator ' + (Number(net.chainId)===56?'valid':'invalid');
}
async function updateBalance(){
  if (!browserProvider || !userAddr) return;
  const bal = await browserProvider.getBalance(userAddr);
  balanceAmount.textContent = trim(fmtEth(bal),4);
  balanceCurrency.textContent = 'BNB';
  mechs.balance.textContent = `${trim(fmtEth(bal),4)} BNB`;
}

/* ================== Renderers ================== */
function populateSelect(selectEl, items, defaultId=0){
  selectEl.innerHTML='';
  for (const it of items){
    const opt = document.createElement('option');
    opt.value = String(it.id); opt.textContent = `#${it.id} — ${it.name}`;
    selectEl.appendChild(opt);
  }
  const fallback = items[0]?.id ?? 0;
  selectEl.value = String(items.some(x=>x.id===defaultId)?defaultId:fallback);
}
async function renderMech(){
  const id = Number(mechs.sel.value);
  const entry = MECHS.find(x=>x.id===id);
  mechs.name.textContent = entry?.name || `Token #${id}`;
  mechs.img.src = ""; mechs.img.alt = "Preview";
  [mechs.img, mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.add("loading"));

  // image
  try{
    const meta = entry?.uri ? await fetchJsonWithFallback(entry.uri) : await load1155Meta(CONTRACT_MECHS,id);
    const img = meta.image || meta.image_url || meta.imageUri || "";
    let i=0; const setNext=()=> mechs.img.src = ipfsHttp(img,i++);
    mechs.img.onerror = ()=>{ if (i<3) setNext(); };
    setNext();
  } catch { mechs.img.alt="Preview unavailable"; }
  finally { mechs.img.classList.remove('loading'); }

  // claim
  try{
    const claim = await readClaim(CONTRACT_MECHS,id);
    const isNative = isZeroAddress(claim.currency);
    if (isNative){
      const price = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : claim.pricePerToken;
      mechs.currency.textContent = 'BNB';
      mechs.price.textContent = `${trim(fmtEth(price))} BNB`;
      const qty = Math.max(1, Number(mechs.qty.value)||1);
      mechs.mint.textContent = `Mint for ${trim(fmtEth(price*BigInt(qty)))} BNB`;
    } else {
      // ERC20 path
      mechs.currency.textContent = 'ERC20';
      mechs.price.textContent = claim.pricePerToken.toString() + ' (raw)';
      const qty = Math.max(1, Number(mechs.qty.value)||1);
      mechs.mint.textContent = `Mint (ERC20) x${qty}`;
    }
    mechs.supply.textContent = `${(claim.claimed||0n).toString()} / ${(claim.max||0n).toString()}`;

    // clamp by wallet limit if any
    const limit = claim.quantityLimitPerWallet ?? 0n;
    const cur = Math.max(1, Number(mechs.qty.value)||1);
    const clamped = (limit>0n) ? Math.min(cur, Number(limit)) : cur;
    if (clamped!==cur){
      mechs.qty.value = clamped;
      setStatus(mechs.status,'warning',`Clamped to wallet limit: ${clamped}`);
    } else setStatus(mechs.status,'','');
  }catch(e){
    setStatus(mechs.status,'warning', prettyRevert(e));
    if (FORCED_MECHS_PRICE_BNB){
      const p = toWei(FORCED_MECHS_PRICE_BNB);
      mechs.currency.textContent='BNB';
      mechs.price.textContent=`${trim(fmtEth(p))} BNB`;
      const qty = Math.max(1, Number(mechs.qty.value)||1);
      mechs.mint.textContent=`Mint for ${trim(fmtEth(p*BigInt(qty)))} BNB`;
    } else {
      mechs.price.textContent="—"; mechs.currency.textContent="—"; mechs.supply.textContent="—";
      mechs.mint.textContent="Mint Mech";
    }
  } finally {
    [mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.remove('loading'));
  }
}
async function renderCryptid(){
  const id = Number(crypt.sel.value);
  const entry = CRYPTIDS.find(x=>x.id===id);
  crypt.name.textContent = entry?.name || `Token #${id}`;
  crypt.img.src=""; crypt.img.alt="Preview";
  crypt.price.textContent="—"; crypt.currency.textContent="—"; crypt.supply.textContent="—"; crypt.balance.textContent="—";
  try{
    const meta = entry?.uri ? await fetchJsonWithFallback(entry.uri) : null;
    const img = meta?.image || meta?.image_url || meta?.imageUri || "";
    let i=0; const setNext=()=> crypt.img.src = ipfsHttp(img,i++);
    crypt.img.onerror=()=>{ if(i<3) setNext(); };
    setNext();
  }catch{ crypt.img.alt="Preview unavailable"; }
}

/* ================== MINT ================== */
const makeAllowlistProof = (pricePer, currency) =>
  ({ proof: [], quantityLimitPerWallet: 0n, pricePerToken: pricePer, currency });

async function mintDrop1155({ contractAddr, tokenId, qty, uiStatusEl }){
  try{
    if (!signer) { await connectWallet(); if(!signer) return; }
    setStatus(uiStatusEl,'warning','Preparing transaction…');

    const claim = await readClaim(contractAddr, tokenId);
    const isNative = isZeroAddress(claim.currency);
    const pricePer = claim.pricePerToken;
    const totalQty = Math.max(1, Number(qty)||1);
    const totalCost = pricePer * BigInt(totalQty);

    const receiver = userAddr;
    const currencyAddr = isNative ? ZERO : claim.currency;
    const allowlist = makeAllowlistProof(pricePer, currencyAddr);
    const args = [receiver, tokenId, totalQty, currencyAddr, pricePer, allowlist, "0x"];

    if (!isNative){
      const erc20 = new ethers.Contract(currencyAddr, ERC20_READ_ABI, signer);
      const [decimals, symbol, balance, allowance] = await Promise.all([
        erc20.decimals(), erc20.symbol(), erc20.balanceOf(userAddr), erc20.allowance(userAddr, contractAddr)
      ]);
      if (balance < totalCost) throw new Error(`Insufficient ${symbol}. Need ${ethers.formatUnits(totalCost,decimals)} ${symbol}.`);
      if (allowance < totalCost) { setStatus(uiStatusEl,'warning',`Approving ${symbol}…`); await safeApprove(currencyAddr, contractAddr, totalCost); }
    } else {
      const bnbBal = await browserProvider.getBalance(userAddr);
      if (bnbBal < totalCost) throw new Error(`Insufficient BNB. Need ${ethers.formatEther(totalCost)} BNB.`);
    }

    // simulate & send
    await simulateClaim({ to: contractAddr, value: isNative? totalCost : 0n, args });
    setStatus(uiStatusEl,'warning','Sending transaction…');
    const rec = await sendRawClaim({ to: contractAddr, value: isNative? totalCost : 0n, args });
    setStatus(uiStatusEl,'success',`Minted ✅  Tx: ${rec.transactionHash.slice(0,10)}…`);
  }catch(e){
    setStatus(uiStatusEl,'error', prettyRevert(e));
    console.error('mintDrop1155:', e);
  }
}

/* ================== Events / Boot ================== */
connectBtn.addEventListener('click', connectWallet);
mechs.sel.addEventListener("change", renderMech);
mechs.qty.addEventListener("change", renderMech);
crypt.sel.addEventListener("change", renderCryptid);
document.getElementById("mechsMint").addEventListener("click", async ()=>{
  const tokenId = Number(mechs.sel.value);
  const qty = Number(mechs.qty.value||1);
  mechs.mint.disabled=true; mechs.mint.classList.add('loading');
  try{ await mintDrop1155({ contractAddr: CONTRACT_MECHS, tokenId, qty, uiStatusEl: mechs.status }); await renderMech(); }
  finally{ mechs.mint.disabled=false; mechs.mint.classList.remove('loading'); }
});

(function boot(){
  // populate selects
  (function populate(selectEl, items){
    selectEl.innerHTML='';
    items.forEach(it=>{
      const o=document.createElement('option'); o.value=String(it.id); o.textContent=`#${it.id} — ${it.name}`; selectEl.appendChild(o);
    });
  })(mechs.sel, MECHS);
  (function populate(selectEl, items){
    selectEl.innerHTML='';
    items.forEach(it=>{
      const o=document.createElement('option'); o.value=String(it.id); o.textContent=`#${it.id} — ${it.name}`; selectEl.appendChild(o);
    });
  })(crypt.sel, CRYPTIDS);

  // first render
  renderMech(); renderCryptid();

  // autoconnect if already authorized
  if (window.ethereum){
    window.ethereum.request({method:'eth_accounts'}).then(async (acc)=>{
      if (acc?.length){
        browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
        signer = await browserProvider.getSigner();
        userAddr = acc[0];
        walletInfo.style.display='flex';
        walletAddress.textContent = shorten(userAddr);
        await updateNetworkIndicator(); await updateBalance();
        window.ethereum.on?.('accountsChanged', handleAccountsChanged);
        window.ethereum.on?.('chainChanged', handleChainChanged);
      }
    }).catch(()=>{});
  }
})();
</script>
</body>
</html>
