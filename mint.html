<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mint Exclusive & Rare NFTs | Tamaquah Nation</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
<style>
  :root { --bg:#0A1A24; --bg2:#051018; --ink:#EAF7FF; --sub:#9CCBE3; --accent:#73E1FF; --gold:#e2c675;
          --metamask:#f6851b; --card:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12);
          --success:#4ade80; --error:#f87171; --warning:#fbbf24; }
  html,body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:Inter,system-ui,Arial,sans-serif;min-height:100vh}
  .wrap{max-width:1200px;margin:0 auto;padding:2rem}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:2rem}
  .brand{font-weight:800;letter-spacing:.08em;font-size:1.5rem;color:var(--accent);text-shadow:0 0 10px rgba(115,225,255,.3)}
  .hero{text-align:center;padding:2rem 0;margin-bottom:3rem}
  .hero h1{font-size:clamp(2rem,5vw,3.5rem);margin:0 0 1rem;text-transform:uppercase;letter-spacing:.06em;
    background:linear-gradient(90deg,var(--accent),var(--gold));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
  .hero p{color:var(--sub);margin:0 auto;max-width:600px;line-height:1.6;font-size:1.1rem}
  .wallet-section{display:flex;flex-direction:column;align-items:center;gap:1rem;margin-bottom:2rem}
  .btn{background:linear-gradient(90deg,var(--metamask),#f8a34d);color:#fff;border:none;border-radius:12px;padding:1rem 2rem;font-weight:700;cursor:pointer;transition:.2s;display:flex;align-items:center;gap:.5rem}
  .btn:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(246,133,27,.3)}
  .btn:disabled{opacity:.7;cursor:not-allowed;transform:none!important}
  .wallet-info{display:flex;gap:1rem;align-items:center;background:rgba(0,0,0,.2);padding:.75rem 1.5rem;border-radius:999px;font-size:.95rem}
  .wallet-address{font-family:monospace;font-size:.9rem}
  .balance{display:flex;gap:.5rem;align-items:center}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(400px,1fr));gap:2rem;margin-top:2rem}
  .card{background:var(--card);border:1px solid var(--stroke);border-radius:16px;padding:1.5rem;box-shadow:0 16px 60px rgba(0,0,0,.35);transition:.3s;position:relative;overflow:hidden}
  .card::before{content:'';position:absolute;top:0;left:0;right:0;height:4px;background:linear-gradient(90deg,var(--accent),var(--gold))}
  .card h2{margin:0 0 1rem;font-size:1.5rem}
  .contract-address{font-size:.85rem;word-break:break-all;color:var(--sub);margin-bottom:1rem;display:block}
  .form-group{display:flex;flex-wrap:wrap;gap:1rem;align-items:center;margin:1rem 0}
  select,input[type=number]{background:#0c1d27;color:var(--ink);border:1px solid var(--stroke);border-radius:10px;padding:.75rem 1rem;min-width:120px}
  .preview{display:flex;gap:1.5rem;margin:1.5rem 0;align-items:flex-start}
  .preview img{width:180px;height:180px;object-fit:cover;border-radius:12px;border:1px solid var(--stroke);background:linear-gradient(45deg,#0c1d27,#0a2738)}
  .meta{flex:1}
  .nft-name{margin:0 0 .5rem;font-size:1.25rem}
  .stat{display:flex;justify-content:space-between;margin:.5rem 0;font-size:.95rem}
  .stat-label{color:var(--sub)}
  .stat-value{font-weight:600}
  .mint-btn{background:linear-gradient(90deg,var(--accent),#a9ffcb);color:#001018;border:none;border-radius:12px;padding:1rem 1.5rem;font-weight:700;cursor:pointer;width:100%;margin-top:1rem}
  .status{min-height:24px;font-size:.9rem;margin-top:.5rem;text-align:center}
  .status.success{color:var(--success)} .status.error{color:var(--error)} .status.warning{color:var(--warning)}
  .loading{position:relative;color:transparent!important}
  .loading:after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:16px;height:16px;border:2px solid rgba(255,255,255,.2);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:translate(-50%,-50%) rotate(360deg)}}
  footer{margin-top:3rem;text-align:center;color:var(--sub);font-size:.9rem;padding:1rem}
  .network-indicator{display:inline-flex;align-items:center;gap:.5rem;font-size:.85rem;padding:.5rem 1rem;border-radius:999px;background:rgba(0,0,0,.2)}
  .network-indicator.valid{background:rgba(74,222,128,.1);color:var(--success)}
  .network-indicator.invalid{background:rgba(248,113,113,.1);color:var(--error)}
  @media (max-width:768px){.wrap{padding:1.5rem}.grid{grid-template-columns:1fr}.preview{flex-direction:column}.preview img{width:100%;height:auto;max-height:300px}}
</style>
</head>
<body>
<div class="wrap">
  <header><div class="brand">TAMAQUAH VAULT</div></header>

  <section class="hero">
    <h1>Mint Exclusive & Rare NFTs</h1>
    <p>Connect your MetaMask wallet to mint these unique digital artifacts from our collections.</p>
  </section>

  <div class="wallet-section">
    <button id="connectBtn" class="btn">
      <svg width="20" height="20" viewBox="0 0 40 37" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M36.0115 3.33203L22.2221 14.2493C21.2623 14.9929 19.7377 14.9929 18.7779 14.2493L4.9885 3.33203" stroke="white" stroke-width="6" stroke-linecap="round"/>
        <path d="M26.2086 23.5947L23.3333 26.0413C21.4609 27.6545 18.5391 27.6545 16.6667 26.0413L13.7914 23.5947" stroke="white" stroke-width="6" stroke-linecap="round"/>
        <rect x="1" y="1" width="38" height="35" rx="6" stroke="white" stroke-width="2"/>
      </svg>
      Connect MetaMask
    </button>
    <div id="walletInfo" style="display:none">
      <div class="wallet-info">
        <span id="walletAddress" class="wallet-address"></span>
        <span class="network-indicator"><span id="networkName">BSC</span></span>
      </div>
      <div class="wallet-info">
        <span class="balance">Balance: <span id="balanceAmount" class="balance-amount">0</span> <span id="balanceCurrency">BNB</span></span>
      </div>
    </div>
    <div id="connStatus" class="status"></div>
  </div>

  <section class="grid">
    <div class="card" id="mechsCard">
      <h2>Ancestral Mechs: Bloodline Codex</h2>
      <span class="contract-address">Contract: 0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989</span>
      <div class="form-group">
        <label for="mechsTokenId">Token ID</label>
        <select id="mechsTokenId"></select>
        <label for="mechsQty">Quantity</label>
        <input id="mechsQty" type="number" min="1" max="10" value="1"/>
      </div>
      <div class="preview">
        <img id="mechsImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="mechsName" class="nft-name">—</h3>
          <div class="stat"><span class="stat-label">Price/Token:</span><span id="mechsPrice" class="stat-value">loading…</span></div>
          <div class="stat"><span class="stat-label">Currency:</span><span id="mechsCurrency" class="stat-value">loading…</span></div>
          <div class="stat"><span class="stat-label">Supply:</span><span id="mechsSupply" class="stat-value">—</span></div>
          <div class="stat"><span class="stat-label">Your Balance:</span><span id="mechsBalance" class="stat-value">—</span></div>
        </div>
      </div>
      <button id="mechsMint" class="mint-btn">Mint Mech</button>
      <div id="mechsStatus" class="status"></div>
    </div>

    <div class="card" id="cryptidsCard">
      <h2>Tribal Punk Cryptids</h2>
      <span class="contract-address">Contract: 0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11</span>
      <div class="form-group">
        <label for="cryptidTokenId">Token ID</label>
        <select id="cryptidTokenId"></select>
        <label for="cryptidQty">Quantity</label>
        <input id="cryptidQty" type="number" min="1" max="10" value="1" disabled/>
      </div>
      <div class="preview">
        <img id="cryptidImg" alt="Preview" loading="lazy"/>
        <div class="meta">
          <h3 id="cryptidName" class="nft-name">—</h3>
          <div class="stat"><span class="stat-label">Price/Token:</span><span id="cryptidPrice" class="stat-value">—</span></div>
          <div class="stat"><span class="stat-label">Currency:</span><span id="cryptidCurrency" class="stat-value">—</span></div>
          <div class="stat"><span class="stat-label">Supply:</span><span id="cryptidSupply" class="stat-value">—</span></div>
          <div class="stat"><span class="stat-label">Your Balance:</span><span id="cryptidBalance" class="stat-value">—</span></div>
        </div>
      </div>
      <button id="cryptidMint" class="mint-btn" disabled>Mint Cryptid (requires signature)</button>
      <div id="cryptidStatus" class="status warning">Mint requires a signed voucher (mintWithSignature). Not enabled on this page.</div>
    </div>
  </section>

  <footer>They took the land. We took the future.</footer>
</div>

<script type="module">
/* ============== CONFIG ============== */
const BSC_CHAIN_ID = 56;
const READ_RPC = "https://bsc-dataseed.binance.org/";

const CONTRACT_MECHS    = "0x2EB40e1dCaA7faFc14040352d7aa37C6D6FBA989"; // Drop1155
const CONTRACT_CRYPTIDS = "0xF98796F28c40b2d0A238B951E72C14Cdf2C4Da11"; // ERC721 (signature mint - preview only)
const KLY_TOKEN         = "0x2e4fEB2Fe668c8Ebe84f19e6c8fE8Cf8131B4E52"; // FYI

// optional UI override for native path (leave null to use on-chain price)
const FORCED_MECHS_PRICE_BNB = null;

/* ============== TOKEN LISTS ============== */
const CRYPTIDS = [
  { id:0,  name:"Wendigo.EXE",                    uri:"ipfs://QmV2X7oUrG5i284sKQPHQJAbQV8HkL788mbZexuCA5oTvx/0" },
  { id:1,  name:"Mask of Memory",                 uri:"ipfs://Qmbu7rbrAoG3cJTYEJGGJ6iZsPGpDQxhkJBsKt4QuBJj8N/0" },
  { id:2,  name:"Wolf of Wounded Knee",           uri:"ipfs://QmQm8nSAL56mGypS45f4AZ44xejVPWuktWidfZqAHdJtmk/0" },
  { id:3,  name:"Coastal Sasquatch Punk",         uri:"ipfs://QmV91qcvQmzwUEu4hin91iXqzVn7hn1F9gZ9bmfxnFTQje/0" },
  { id:4,  name:"Anishinaabe Wendigo Protocol",   uri:"ipfs://QmStEaLkFwNREJ3M4t42hNKvphwjHK1MxjA7CUdW15d6BE/0" },
  { id:5,  name:"Desert Skinwalker Punk",         uri:"ipfs://QmcW6m3B1ygPoMrsr4qVMaNC4uCL1s4EAq2LcdEsCj6iUS/0" },
  { id:6,  name:"Métis Rougarou Rider",           uri:"ipfs://Qmeg78oUMrM1fUGNMVzUNG2G5dEDuD8TLoB9Mh3j3X6zEF/0" },
  { id:7,  name:"Cherokee Skinwalker Firewall",   uri:"ipfs://QmWNsSbcy2iBmYjK2TCzELZTfzD1ezGj1WvktYiwnWnjjg/0" },
  { id:8,  name:"Wabanaki Webworm",               uri:"ipfs://QmdadZMbe1QMUW5i51smLxEDuWvRWKanLiiHdyb4zH2mbM/0" },
  { id:9,  name:"Deer Woman DAO",                 uri:"ipfs://QmTmrUDMXuqnffe1duAEYdJGAKNeSdEsVvKe8dT8YKR4i7/0" },
  { id:10, name:"The Cipherskin Codex",           uri:"ipfs://QmPcWyNf93hwKXxBH5QpseeqmkE296arM1jkg4zcvi3bgC/0" },
  { id:11, name:"Treaty.Exe",                     uri:"ipfs://QmeGbsj4E3w9zaaEnQiSsDUrPUbbTWumn8BemBnsHNdFuR/0" },
  { id:12, name:"Scroll of Unburied Seeds",       uri:"ipfs://QmNXhjcuNvaYDW7PdDi7Erh1jbkhQb6ep15FAYcXVZUByE/0" },
  { id:13, name:"The Disentrancer",               uri:"ipfs://QmQP3hP9YyAkFZwKNkrw5apxEcZ7nAZecshsaE1sdpyGaz/0" },
  { id:14, name:"Ledger Shaman",                  uri:"ipfs://QmNj8tHVjp4X1HNBFbm4nbw6mb2vzdMHrYDd8wQuE35qFw/0" },
  { id:15, name:"The Ghost of Paper Genocide",    uri:"ipfs://QmWbTfxSn4Mybnw3deUiFn3T8PVyyJkiCPZD9C91Sqz9Kk/0" },
  { id:16, name:"Ironroot Codewalker",            uri:"ipfs://QmWMhG22wfXFZufu7E2haVkqoc1XYf4bU8KXvVL6xUZZXW/0" },
  { id:17, name:"Deer Woman 9.0",                 uri:"ipfs://QmRieQJ4gpkjMsJkaB99t2M5BX5sns6CWVJPa3HNwASCEB/0" },
  { id:18, name:"Thunderbird 9G",                 uri:"ipfs://QmPnk3rYUeqeCevm7pjjfp31WrsUp8CzBP96TVRmmFky7h/0" },
  { id:19, name:"Skinwalker 9S",                  uri:"ipfs://Qmbv4hEy6gW68XSUUW46nzYmptaxiWS1vFGig3457W1Wez/0" },
];
const MECHS = [{ id:0, name:"Skybone Leviathan", uri:"ipfs://QmXZaUkWziGrd2ooyXdQavJmPXCtWFjZrGL9239n4Nu7yU/0" }];

/* ============== ABIs (exact from your contract) ============== */
const MECHS_READ_ABI = [
  "function uri(uint256) view returns (string)",
  "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
  "function getClaimConditionById(uint256 _tokenId,uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata))"
];
const MECHS_CLAIM_ABI = [
  "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable"
];
// All custom errors you pasted (for readable revert decoding)
const MECHS_ERROR_ABI = [
  "error BatchMintInvalidBatchId(uint256 index)",
  "error BatchMintInvalidTokenId(uint256 tokenId)",
  "error BatchMintMetadataFrozen(uint256 batchId)",
  "error ContractMetadataUnauthorized()",
  "error CurrencyTransferLibFailedNativeTransfer(address recipient,uint256 value)",
  "error DropClaimExceedLimit(uint256 expected,uint256 actual)",
  "error DropClaimExceedMaxSupply(uint256 expected,uint256 actual)",
  "error DropClaimInvalidTokenPrice(address expectedCurrency,uint256 expectedPricePerToken,address actualCurrency,uint256 actualExpectedPricePerToken)",
  "error DropClaimNotStarted(uint256 expected,uint256 actual)",
  "error DropExceedMaxSupply()",
  "error DropNoActiveCondition()",
  "error DropUnauthorized()",
  "error LazyMintInvalidAmount()",
  "error LazyMintUnauthorized()",
  "error OwnableUnauthorized()",
  "error PermissionsAlreadyGranted(address account,bytes32 role)",
  "error PermissionsInvalidPermission(address expected,address actual)",
  "error PermissionsUnauthorizedAccount(address account,bytes32 neededRole)",
  "error PlatformFeeExceededMaxFeeBps(uint256 max,uint256 actual)",
  "error PlatformFeeInvalidRecipient(address recipient)",
  "error PlatformFeeUnauthorized()",
  "error PrimarySaleInvalidRecipient(address recipient)",
  "error PrimarySaleUnauthorized()",
  "error RoyaltyExceededMaxFeeBps(uint256 max,uint256 actual)",
  "error RoyaltyInvalidRecipient(address recipient)",
  "error RoyaltyUnauthorized()"
];
// (preview only) ERC721
const ERC721_READ_ABI = [ "function tokenURI(uint256 tokenId) view returns (string)" ];
// ERC20 helpers
const ERC20_ABI = [
  "function approve(address spender,uint256 amount) returns (bool)",
  "function allowance(address owner,address spender) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint256)",
  "function symbol() view returns (string)"
];

/* ============== DOM ============== */
const connectBtn = document.getElementById('connectBtn');
const walletInfo = document.getElementById('walletInfo');
const walletAddress = document.getElementById('walletAddress');
const networkName = document.getElementById('networkName');
const balanceAmount = document.getElementById('balanceAmount');
const balanceCurrency = document.getElementById('balanceCurrency');
const connStatus = document.getElementById('connStatus');

const mechs = {
  sel: document.getElementById("mechsTokenId"), qty: document.getElementById("mechsQty"),
  img: document.getElementById("mechsImg"), name: document.getElementById("mechsName"),
  price: document.getElementById("mechsPrice"), currency: document.getElementById("mechsCurrency"),
  supply: document.getElementById("mechsSupply"), balance: document.getElementById("mechsBalance"),
  mint: document.getElementById("mechsMint"), status: document.getElementById("mechsStatus")
};
const crypt = {
  sel: document.getElementById("cryptidTokenId"), qty: document.getElementById("cryptidQty"),
  img: document.getElementById("cryptidImg"), name: document.getElementById("cryptidName"),
  price: document.getElementById("cryptidPrice"), currency: document.getElementById("cryptidCurrency"),
  supply: document.getElementById("cryptidSupply"), balance: document.getElementById("cryptidBalance"),
  mint: document.getElementById("cryptidMint"), status: document.getElementById("cryptidStatus")
};

/* ============== Providers / State ============== */
const readProvider = new ethers.JsonRpcProvider(READ_RPC);
let browserProvider = null, signer = null, userAddr = null;

/* ============== Utils ============== */
const shorten = a => a ? `${a.slice(0,6)}…${a.slice(-4)}` : "—";
const ZERO = ethers.ZeroAddress;
const idToHex = n => n.toString(16).padStart(64,"0").toLowerCase();
const fmtEth = v => ethers.formatEther(v);
const toWei  = s => ethers.parseEther(s);
const trimEther = (s,dec=6)=>{ const [i,f='']=String(s).split('.'); return f?`${i}.${f.slice(0,dec)}`:`${i}.${'0'.repeat(dec)}`; };
function decodeErr(e){
  if (e?.errorName) {
    const args = e?.errorArgs ? JSON.stringify(e.errorArgs, (_,v)=> typeof v==="bigint"?v.toString():v) : "";
    return `${e.errorName}${args && args!=="[]" ? " " + args : ""}`;
  }
  return e?.error?.message || e?.info?.error?.message || e?.data?.message || e?.reason || e?.shortMessage || e?.message || 'Unknown error';
}
function setStatus(elOrType, typeOrMsg="", maybeMsg=""){
  let el = connStatus, type = typeOrMsg, msg = maybeMsg;
  if (typeof elOrType !== 'string'){ el = elOrType || connStatus; type = typeOrMsg; msg = maybeMsg; }
  else { type = elOrType; msg = typeOrMsg; }
  el.textContent = msg; el.className = "status " + (type||"");
}
function ipfsHttp(url, i=0){
  if (!url) return ""; if (!url.startsWith("ipfs://")) return url;
  const p = url.slice(7);
  const gws = ["https://ipfs.io/ipfs/","https://cloudflare-ipfs.com/ipfs/","https://gateway.pinata.cloud/ipfs/"];
  return gws[Math.min(i,gws.length-1)] + p;
}
async function fetchJsonWithFallback(ipfsUrl){
  let lastErr; for (let i=0;i<3;i++){ try{
    const r = await fetch(ipfsHttp(ipfsUrl,i)); if (!r.ok) throw new Error(`HTTP ${r.status}`); return await r.json();
  }catch(e){ lastErr=e; } } throw lastErr || new Error("Fetch failed");
}
function populateSelect(selectEl, items, defaultId=0){
  selectEl.innerHTML = '';
  for (const it of items){
    const opt = document.createElement('option');
    opt.value = String(it.id);
    opt.textContent = `#${it.id} — ${it.name}`;
    selectEl.appendChild(opt);
  }
  const fallback = items[0]?.id ?? 0;
  selectEl.value = String(items.some(x => x.id === defaultId) ? defaultId : fallback);
}

/* ===== Revert-friendly interface + helpers (core fix) ===== */
const FULL_MECHS_IFACE = new ethers.Interface([
  ...MECHS_CLAIM_ABI,
  ...MECHS_ERROR_ABI
]);

function prettyRevert(e){
  const data = e?.data || e?.error?.data || e?.info?.error?.data || e?.error?.error?.data;
  if (typeof data === "string" && data.startsWith("0x")){
    try {
      const dec = FULL_MECHS_IFACE.decodeErrorResult(data);
      const args = Array.isArray(dec.args) && dec.args.length
        ? " " + JSON.stringify(dec.args.map(a => (typeof a === "bigint" ? a.toString() : a)))
        : "";
      return `${dec.name}${args}`;
    } catch {}
  }
  return decodeErr(e);
}

// simulate (eth_call) using raw data — no result decoding on success path
async function simulateClaim({ to, value, args }){
  const data = FULL_MECHS_IFACE.encodeFunctionData("claim", args);
  try{
    await signer.call({ to, data, value });
  }catch(e){
    throw new Error(prettyRevert(e));
  }
}

// send raw transaction (no Contract wrapper => no "decode result data")
async function sendRawClaim({ to, value, args }){
  const data = FULL_MECHS_IFACE.encodeFunctionData("claim", args);
  let gasLimit;
  try{
    const est = await signer.estimateGas({ to, data, value });
    gasLimit = (est * 120n) / 100n; // +20% buffer
  }catch{}
  const tx = await signer.sendTransaction({ to, data, value, ...(gasLimit ? { gasLimit } : {}) });
  return await tx.wait();
}

/* ============== Wallet ============== */
async function connectWallet(){
  try{
    if (!window.ethereum) throw new Error('MetaMask not detected. Please install MetaMask.');
    connectBtn.disabled = true; connectBtn.classList.add('loading');
    setStatus('warning','Connecting to MetaMask…');

    browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
    await browserProvider.send('eth_requestAccounts',[]);

    const net = await browserProvider.getNetwork();
    if (Number(net.chainId) !== BSC_CHAIN_ID){
      try{
        await browserProvider.send('wallet_switchEthereumChain',[{ chainId:'0x'+BSC_CHAIN_ID.toString(16) }]);
      }catch(err){
        if (err?.code === 4902){
          await browserProvider.send('wallet_addEthereumChain',[{
            chainId:'0x'+BSC_CHAIN_ID.toString(16),
            chainName:'Binance Smart Chain',
            nativeCurrency:{ name:'BNB', symbol:'BNB', decimals:18 },
            rpcUrls:['https://bsc-dataseed1.bnbchain.org','https://bsc-dataseed2.bnbchain.org','https://bsc-dataseed.binance.org'],
            blockExplorerUrls:['https://bscscan.com/']
          }]);
        } else throw err;
      }
    }

    signer = await browserProvider.getSigner();
    userAddr = await signer.getAddress();

    window.ethereum.on?.('accountsChanged', handleAccountsChanged);
    window.ethereum.on?.('chainChanged', handleChainChanged);

    connectBtn.textContent = 'Connected';
    walletInfo.style.display = 'flex';
    walletAddress.textContent = shorten(userAddr);
    await updateNetworkIndicator();
    await updateBalance();
    await renderMech();
    setStatus('success','Connected to MetaMask');
  } catch(e){
    setStatus('error', decodeErr(e));
  } finally {
    connectBtn.disabled = false; connectBtn.classList.remove('loading');
  }
}
function handleAccountsChanged(acc){
  if (!acc?.length) return disconnectWallet();
  userAddr = acc[0];
  walletAddress.textContent = shorten(userAddr);
  updateBalance(); renderMech();
}
function handleChainChanged(){ if (window.ethereum) browserProvider = new ethers.BrowserProvider(window.ethereum,'any'); updateNetworkIndicator(); updateBalance(); renderMech(); }
function disconnectWallet(){
  try{
    window.ethereum?.removeListener?.('accountsChanged', handleAccountsChanged);
    window.ethereum?.removeListener?.('chainChanged', handleChainChanged);
  }catch{}
  browserProvider = null; signer = null; userAddr = null;
  connectBtn.textContent = 'Connect MetaMask';
  walletInfo.style.display = 'none';
  connStatus.textContent = '';
}
async function updateNetworkIndicator(){
  const indicator = document.querySelector('.network-indicator');
  if (!browserProvider || !indicator) return;
  const net = await browserProvider.getNetwork();
  const cid = Number(net.chainId);
  networkName.textContent = (cid===56?'BSC':`Chain ${cid}`);
  indicator.className = 'network-indicator ' + (cid===BSC_CHAIN_ID ? 'valid' : 'invalid');
}
async function updateBalance(){
  if (!browserProvider || !userAddr) return;
  const bal = await browserProvider.getBalance(userAddr);
  balanceAmount.textContent = trimEther(fmtEth(bal),4);
  balanceCurrency.textContent = 'BNB';
  mechs.balance.textContent = `${trimEther(fmtEth(bal),4)} BNB`;
}

/* ============== Read helpers (MECHS) ============== */
async function load1155Meta(contractAddr, tokenId){
  try{
    const c = new ethers.Contract(contractAddr, MECHS_READ_ABI, readProvider);
    const base = await c.uri(tokenId);
    const url = base.includes("{id}") ? base.replace("{id}", idToHex(tokenId)) : base;
    return await fetchJsonWithFallback(url);
  }catch{ return {}; }
}
async function readClaim(contractAddr, tokenId){
  try{
    const c = new ethers.Contract(contractAddr, MECHS_READ_ABI, readProvider);
    const condId = await c.getActiveClaimConditionId(tokenId);
    const cond = await c.getClaimConditionById(tokenId, condId);
    return {
      max: cond.maxClaimableSupply,
      claimed: cond.supplyClaimed,
      quantityLimitPerWallet: cond.quantityLimitPerWallet,
      pricePerToken: cond.pricePerToken,
      currency: cond.currency
    };
  }catch(e){ throw new Error("Claim read failed: " + decodeErr(e)); }
}

/* ============== Renderers ============== */
async function renderMech(){
  const id = Number(mechs.sel.value);
  const entry = MECHS.find(x=>x.id===id);
  mechs.name.textContent = entry?.name || `Token #${id}`;
  mechs.img.src = ""; mechs.img.alt = "Preview";
  [mechs.img, mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.add("loading"));

  try {
    const meta = entry?.uri ? await fetchJsonWithFallback(entry.uri) : await load1155Meta(CONTRACT_MECHS, id);
    const img = meta.image || meta.image_url || meta.imageUri || "";
    let i=0; const setNext=()=> mechs.img.src = ipfsHttp(img,i++);
    mechs.img.onerror = ()=>{ if (i<3) setNext(); }; setNext();
  } catch { mechs.img.alt = "Preview unavailable"; }
  finally { mechs.img.classList.remove("loading"); }

  try {
    const claim = await readClaim(CONTRACT_MECHS, id);
    const isNative = (claim.currency === ZERO);

    if (isNative) {
      const price = FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : claim.pricePerToken;
      mechs.currency.textContent = 'BNB';
      mechs.price.textContent = `${trimEther(fmtEth(price))} BNB`;
      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      mechs.mint.textContent = `Mint for ${trimEther(fmtEth(price * BigInt(qty)))} BNB (est.)`;
    } else {
      mechs.currency.textContent = 'ERC20';
      mechs.price.textContent = `${claim.pricePerToken.toString()} (raw units)`;
      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      mechs.mint.textContent = `Mint (ERC20) x${qty}`;
    }

    mechs.supply.textContent = `${(claim.claimed||0n).toString()} / ${(claim.max||0n).toString()}`;

    const maxPerWallet = claim.quantityLimitPerWallet ?? 0n;
    const currentQty = Math.max(1, Number(mechs.qty.value) || 1);
    const clamped = (maxPerWallet>0n) ? Math.min(currentQty, Number(maxPerWallet)) : currentQty;
    if (clamped !== currentQty){
      mechs.qty.value = clamped;
      setStatus(mechs.status, "warning", `Clamped to wallet limit: ${clamped}`);
    } else setStatus(mechs.status, "", "");
  } catch(e){
    setStatus(mechs.status, "warning", decodeErr(e));
    if (FORCED_MECHS_PRICE_BNB){
      const p = toWei(FORCED_MECHS_PRICE_BNB);
      mechs.currency.textContent = 'BNB';
      mechs.price.textContent = `${trimEther(fmtEth(p))} BNB`;
      const qty = Math.max(1, Number(mechs.qty.value) || 1);
      mechs.mint.textContent = `Mint for ${trimEther(fmtEth(p * BigInt(qty)))} BNB (est.)`;
    } else {
      mechs.price.textContent="—"; mechs.currency.textContent="—"; mechs.supply.textContent="—";
      mechs.mint.textContent = "Mint Mech";
    }
  } finally {
    [mechs.price, mechs.currency, mechs.supply].forEach(el=>el.classList.remove("loading"));
  }
}

async function renderCryptid(){
  const id = Number(crypt.sel.value);
  const entry = CRYPTIDS.find(x=>x.id===id);
  crypt.name.textContent = entry?.name || `Token #${id}`;
  crypt.img.src = ""; crypt.img.alt = "Preview";
  [crypt.img].forEach(el=>el.classList.add("loading"));

  try {
    const meta = entry?.uri ? await fetchJsonWithFallback(entry.uri) : null;
    const img = meta?.image || meta?.image_url || meta?.imageUri || "";
    let i=0; const setNext=()=> crypt.img.src = ipfsHttp(img,i++);
    crypt.img.onerror = ()=>{ if (i<3) setNext(); }; setNext();
  } catch { crypt.img.alt = "Preview unavailable"; }
  finally { crypt.img.classList.remove("loading"); }

  crypt.price.textContent = "—";
  crypt.currency.textContent = "—";
  crypt.supply.textContent = "—";
  crypt.balance.textContent = "—";
}

/* ============== Mint (MECHS) ============== */
const makeAllowlistProof = (pricePer, currency) =>
  ({ proof: [], quantityLimitPerWallet: 0n, pricePerToken: pricePer, currency });

async function mintMech(){
  try{
    if (!signer) { await connectWallet(); if (!signer) return; }
    mechs.mint.disabled = true; mechs.mint.classList.add("loading");
    setStatus(mechs.status, "warning", "Preparing transaction…");

    const tokenId = Number(mechs.sel.value);
    const qty = Math.max(1, Number(mechs.qty.value) || 1);

    const claim = await readClaim(CONTRACT_MECHS, tokenId);
    const isNative = (claim.currency === ZERO);

    let pricePer = isNative
      ? (FORCED_MECHS_PRICE_BNB ? toWei(FORCED_MECHS_PRICE_BNB) : claim.pricePerToken)
      : claim.pricePerToken;

    const currencyAddr = isNative ? ZERO : claim.currency;
    const allowlist = makeAllowlistProof(pricePer, currencyAddr);

    if (isNative){
      const totalValue = pricePer * BigInt(qty);
      const userBalance = await browserProvider.getBalance(userAddr);
      if (userBalance < totalValue) throw new Error(`Insufficient BNB. Need ${trimEther(fmtEth(totalValue))} BNB.`);

      // (1) simulate to catch/format reverts
      await simulateClaim({
        to: CONTRACT_MECHS,
        value: totalValue,
        args: [userAddr, tokenId, qty, ZERO, pricePer, allowlist, "0x"]
      });

      // (2) send raw (no decode on success)
      setStatus(mechs.status,"warning","Sending transaction…");
      const rec = await sendRawClaim({
        to: CONTRACT_MECHS,
        value: totalValue,
        args: [userAddr, tokenId, qty, ZERO, pricePer, allowlist, "0x"]
      });
      setStatus(mechs.status,"success",`Minted! Tx: ${rec.transactionHash.slice(0,10)}…`);
    } else {
      // ERC20 route
      const erc20 = new ethers.Contract(currencyAddr, ERC20_ABI, signer);
      const [decimals, symbol, balance, allowance] = await Promise.all([
        erc20.decimals(), erc20.symbol(), erc20.balanceOf(userAddr), erc20.allowance(userAddr, CONTRACT_MECHS)
      ]);
      const total = pricePer * BigInt(qty);
      if (balance < total) throw new Error(`Insufficient ${symbol}. Need ${ethers.formatUnits(total, decimals)} ${symbol}.`);
      if (allowance < total){
        setStatus(mechs.status, "warning", `Approving ${symbol}…`);
        const txA = await erc20.approve(CONTRACT_MECHS, total);
        await txA.wait();
      }

      // (1) simulate (no value for ERC20)
      await simulateClaim({
        to: CONTRACT_MECHS,
        value: 0n,
        args: [userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, "0x"]
      });

      // (2) send raw
      setStatus(mechs.status,"warning","Sending transaction…");
      const rec = await sendRawClaim({
        to: CONTRACT_MECHS,
        value: 0n,
        args: [userAddr, tokenId, qty, currencyAddr, pricePer, allowlist, "0x"]
      });
      setStatus(mechs.status,"success",`Minted! Tx: ${rec.transactionHash.slice(0,10)}…`);
    }

    await renderMech();
  } catch(e){
    setStatus(mechs.status, "error", prettyRevert(e));
    console.error('mintMech:', e);
  } finally {
    mechs.mint.disabled = false; mechs.mint.classList.remove("loading");
  }
}

/* ============== Events / Boot ============== */
mechs.sel.addEventListener("change", renderMech);
mechs.qty.addEventListener("change", renderMech);
document.getElementById("cryptidTokenId").addEventListener("change", renderCryptid);
document.getElementById("cryptidQty").addEventListener("change", renderCryptid);
document.getElementById("mechsMint").addEventListener("click", mintMech);
connectBtn.addEventListener("click", connectWallet);

(async function boot(){
  populateSelect(mechs.sel, MECHS, 0);
  populateSelect(crypt.sel, CRYPTIDS, 0);
  await renderMech();
  await renderCryptid();

  if (window.ethereum){
    const acc = await window.ethereum.request({ method:'eth_accounts' });
    if (acc?.length){
      browserProvider = new ethers.BrowserProvider(window.ethereum,'any');
      signer = await browserProvider.getSigner();
      userAddr = acc[0];
      connectBtn.textContent = 'Connected';
      walletInfo.style.display = 'flex';
      walletAddress.textContent = shorten(userAddr);
      await updateNetworkIndicator();
      await updateBalance();
      window.ethereum.on?.('accountsChanged', handleAccountsChanged);
      window.ethereum.on?.('chainChanged', handleChainChanged);
    }
  }
})();
</script>
</body>
</html>
